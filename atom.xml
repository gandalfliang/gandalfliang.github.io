<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gandalfliang的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gandalfliang.github.io/"/>
  <updated>2019-01-23T11:02:39.662Z</updated>
  <id>https://gandalfliang.github.io/</id>
  
  <author>
    <name>gandalfliang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tags for the past Two years</title>
    <link href="https://gandalfliang.github.io/2019/01/23/tags-for-the-past-two-years/"/>
    <id>https://gandalfliang.github.io/2019/01/23/tags-for-the-past-two-years/</id>
    <published>2019-01-23T10:56:15.000Z</published>
    <updated>2019-01-23T11:02:39.662Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/23/tags-for-the-past-two-years/tags.png" class="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/01/23/tags-for-the-past-two-years/tags.png&quot; class=&quot;&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定位 C++/CLI 库的加载失败异常</title>
    <link href="https://gandalfliang.github.io/2019/01/22/c-cli-debug-assembly-load-error/"/>
    <id>https://gandalfliang.github.io/2019/01/22/c-cli-debug-assembly-load-error/</id>
    <published>2019-01-22T11:18:13.000Z</published>
    <updated>2019-01-23T03:22:28.042Z</updated>
    
    <content type="html"><![CDATA[<p>程序在加载 C++/CLI 动态库的时候，出现 <code>FileLoadException</code>，常见错误是其中某些依赖没有找到，这个时候异常信息应该是类似：一个xxx的依赖没有找到；这个问题很好解决，确定缺少的依赖补充上就可以了，可以使用 <code>dumpbin</code> 工具查看相关的依赖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /dependents target.dll</span><br></pre></td></tr></table></figure><br>但是，有一种比较隐晦的错误导致动态库加载失败，错误提示：<code>未能加载由xxx.dll导入的过程</code>，除了这些，几乎没有什么有用的错误信息让我们来确定到底出现了什么问题。一般来说，按照目前我遇到的问题，这个一般都是对应的库文件调用了当前平台不支持的api导致的。当然，这个问题不易在开发的机器上发现，因为能调用到这个api就代表调试机器上有对应平台版本的SDK，一般如果前期没有发现到这个问题，那么问题被发现时肯定是在生成环境，所以需要开发人员注意调用接口的支持平台。  </p><p>要定位是什么接口导致的问题，需要借助其他的调试工具来排查。微软的 Windows SDK 提供了对应的工具 <code>gflags.exe</code>，借助这个工具，我们可以在调试的过程中看到详细的动态库加载信息，在这些信息中可以定位到底是什么接口导致库文件加载失败。当然，你需要在出现问题的机器上使用这个工具进行操作，并通过 Visual Studio 进行远程调试。  </p><img src="/2019/01/22/c-cli-debug-assembly-load-error/gflags.png" class="">  <p>如上图显示，通过输入你程序的名字和开启 <code>Show loader snaps</code> 开关，应用后使用 Visual Studio 进行调试，可以在输出窗口看到详细的加载信息： </p><img src="/2019/01/22/c-cli-debug-assembly-load-error/locate_error.png" class="">  ]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序在加载 C++/CLI 动态库的时候，出现 &lt;code&gt;FileLoadException&lt;/code&gt;，常见错误是其中某些依赖没有找到，这个时候异常信息应该是类似：一个xxx的依赖没有找到；这个问题很好解决，确定缺少的依赖补充上就可以了，可以使用 &lt;code&gt;dump
      
    
    </summary>
    
      <category term="调试" scheme="https://gandalfliang.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="Visual Studio" scheme="https://gandalfliang.github.io/tags/Visual-Studio/"/>
    
      <category term="C++/CLI" scheme="https://gandalfliang.github.io/tags/C-CLI/"/>
    
      <category term="调试" scheme="https://gandalfliang.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JIT Loop Invariant Hoisting</title>
    <link href="https://gandalfliang.github.io/2019/01/17/jit-loop-invariant-hoisting/"/>
    <id>https://gandalfliang.github.io/2019/01/17/jit-loop-invariant-hoisting/</id>
    <published>2019-01-17T11:06:38.000Z</published>
    <updated>2021-02-10T03:52:13.733Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>在上一篇<a href="./2019/01/15/loop-hoisting/">文章</a>中，我们已经对 <code>Loop Invariant</code> 概念有一个简单的了解，在文章的最后提到的 <code>Loop Invariant</code> 将在这篇文章做一个简单的介绍。</p><h2 id="在我们开始之前"><a href="#在我们开始之前" class="headerlink" title="在我们开始之前"></a>在我们开始之前</h2><p>如果你了解 <code>C#</code> 程序的运行，应该知道 <code>C#</code> 代码先被编译器编译为 <code>MSIL</code> 中间代码，在实际运行的时候才通过 <code>JIT</code> 编译器将 <code>MSIL</code> 代码编译成机器代码并运行。因此，编译器有两个时段可以对代码进行优化：</p><ul><li><strong>C#</strong> -&gt; <strong>MSIL</strong></li><li><strong>MSIL</strong> -&gt; <strong>MACHINE CODE</strong>  <a id="more"></a>但是，C#到MSIL的优化有限，大部分优化都是通过 <code>JIT</code> 来完成的。而这篇文章也是围绕微软最新的 <code>RyuJIT</code> 编译器来展开，其可能与旧的 <code>JIT</code>有所区别，但是应该差异不大。</li></ul><h2 id="Loop-Invariant"><a href="#Loop-Invariant" class="headerlink" title="Loop Invariant"></a>Loop Invariant</h2><p>首先看一下微软对 <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md#loop-invariant-code-hoisting" target="_blank" rel="noopener"><code>Loop Invariant Code Hoisting</code></a> 的说明：</p><blockquote><p>This phase traverses all the loop nests, in outer-to-inner order (thus hoisting expressions outside the largest loop in which they are invariant). It traverses all of the statements in the blocks in the loop that are always executed. If the statement is:  </p><ul><li>A valid CSE candidate</li><li>Has no side-effects</li><li>Does not raise an exception OR occurs in the loop prior to any side-effects</li><li>Has a valid value number, and it is a lclVar defined outside the loop, or its children (the value numbers from which it was computed) are invariant.</li></ul></blockquote><p><code>JIT</code> 从外到内遍历所有的循环嵌套。它遍历循环嵌套结构中始终会被运行的<code>BasicBlock</code>（这是<code>JIT</code>里的类型，这里暂不展开，你可以暂时将其理解为编译器的基本类型）里的语句，并且这些语句符合以下条件：  </p><ul><li>是一个 <code>CSE</code></li><li>没有副作用</li><li>不会触发异常或者发生在任何副作用之前</li><li>拥有一个可用的数字，这个数字定义在循环嵌套外或者其子元素是不可变的</li></ul><hr><p>上面提到的始终会被运行的循环嵌套（loop that are always executed), 如何理解? 嗯…，简单来讲，我们知道的循环结构，例如大部分编程语言都会有的 for loop 和 do while loop，这两种循环嵌套中，do while loop 就符合一定会被执行的循环嵌套，因为循环判断在一次循环后才会执行，而有些for loop 也可以被转换为 do while loop, <code>JIT</code> 会判断这个loop能否转换为do while loop后才进行后续的 loop hoisting 操作。</p><h2 id="CSE-Common-Subexpression-Elimination"><a href="#CSE-Common-Subexpression-Elimination" class="headerlink" title="CSE - Common Subexpression Elimination"></a>CSE - Common Subexpression Elimination</h2><blockquote><p>Utilizes value numbers to identify redundant computations, which are then evaluated to a new temp lvlVar, and then reused.</p></blockquote><p>利用数字来识别（替代？）多余的计算，然后将它们计算为新的临时值，并重复利用。就如上篇文章中for循环中的 <code>x+y</code>。<br>观察<code>RyuJIT</code> 中用于判定<code>CSE</code>的函数片段：  </p><p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*****************************************************************************</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> *  The following determines whether the given expression is a worthy CSE</span></span><br><span class="line"><span class="hljs-comment"> *  candidate.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Compiler::optIsCSEcandidate</span><span class="hljs-params">(GenTreePtr tree)</span></span></span><br><span class="line"><span class="hljs-function"></span>{</span><br><span class="line">     <span class="hljs-comment">/* No good if the expression contains side effects or if it was marked as DONT CSE */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span>  (tree-&gt;gtFlags &amp; (GTF_ASG|GTF_DONT_CSE))</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/* The only reason a TYP_STRUCT tree might occur is as an argument to</span></span><br><span class="line"><span class="hljs-comment">       GT_ADDR. It will never be actually materialized. So ignore them.</span></span><br><span class="line"><span class="hljs-comment">       Also TYP_VOIDs */</span></span><br><span class="line"></span><br><span class="line">    var_types   type = tree-&gt;TypeGet();</span><br><span class="line">    genTreeOps  oper = tree-&gt;OperGet();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (type == TYP_STRUCT || type == TYP_VOID)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _TARGET_X86_</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (type == TYP_FLOAT)</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-comment">// TODO-X86-CQ: Revisit this</span></span><br><span class="line">        <span class="hljs-comment">// Don't CSE a TYP_FLOAT on x86 as we currently can only enregister doubles </span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></span><br><span class="line">    <span class="hljs-keyword">if</span> (oper == GT_CNS_DBL)</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-comment">// TODO-CQ: Revisit this</span></span><br><span class="line">        <span class="hljs-comment">// Don't try to CSE a GT_CNS_DBL as they can represent both float and doubles</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  <span class="hljs-comment">/* Check for some special cases */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> (oper)</span><br><span class="line">    {</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">case</span> GT_LCL_VAR:</span><br><span class="line">        <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;   <span class="hljs-comment">// Can't CSE a volatile LCL_VAR</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>当然，这个函数还有许多细节，这里只挑选几个典型的片段。看代码可以知道：  <p></p><ul><li><strong>可以明确指定不能使用 CSE</strong></li><li><strong>不能有赋值表达式</strong></li><li><strong>在x86下 float 不能作为 CSE, x64 下不支持 float 和 double</strong></li><li><strong>不支持 struct 和 void</strong> </li><li><strong>如果是可变 (volatile) 的变量，也不能作为CSE，这在之前的一篇<a href="https://gandalfliang.github.io/2018/12/26/csharp-memory-model-part-1/">文章</a>中有对 volatile 的说明</strong></li></ul><p><code>Loop-Hoisting</code> 还有颇多细节这里并没有覆盖，有兴趣可以去看源码：<a href="https://github.com/dotnet/coreclr/blob/master/src/jit/optimizer.cpp" target="_blank" rel="noopener">https://github.com/dotnet/coreclr/blob/master/src/jit/optimizer.cpp</a></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在上一篇&lt;a href=&quot;./2019/01/15/loop-hoisting/&quot;&gt;文章&lt;/a&gt;中，我们已经对 &lt;code&gt;Loop Invariant&lt;/code&gt; 概念有一个简单的了解，在文章的最后提到的 &lt;code&gt;Loop Invariant&lt;/code&gt; 将在这篇文章做一个简单的介绍。&lt;/p&gt;
&lt;h2 id=&quot;在我们开始之前&quot;&gt;&lt;a href=&quot;#在我们开始之前&quot; class=&quot;headerlink&quot; title=&quot;在我们开始之前&quot;&gt;&lt;/a&gt;在我们开始之前&lt;/h2&gt;&lt;p&gt;如果你了解 &lt;code&gt;C#&lt;/code&gt; 程序的运行，应该知道 &lt;code&gt;C#&lt;/code&gt; 代码先被编译器编译为 &lt;code&gt;MSIL&lt;/code&gt; 中间代码，在实际运行的时候才通过 &lt;code&gt;JIT&lt;/code&gt; 编译器将 &lt;code&gt;MSIL&lt;/code&gt; 代码编译成机器代码并运行。因此，编译器有两个时段可以对代码进行优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C#&lt;/strong&gt; -&amp;gt; &lt;strong&gt;MSIL&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MSIL&lt;/strong&gt; -&amp;gt; &lt;strong&gt;MACHINE CODE&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C#" scheme="https://gandalfliang.github.io/tags/C/"/>
    
      <category term="RyuJIT" scheme="https://gandalfliang.github.io/tags/RyuJIT/"/>
    
      <category term="编译器优化" scheme="https://gandalfliang.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="Loop Hoisting" scheme="https://gandalfliang.github.io/tags/Loop-Hoisting/"/>
    
      <category term="Loop Invariant Hoisting" scheme="https://gandalfliang.github.io/tags/Loop-Invariant-Hoisting/"/>
    
  </entry>
  
  <entry>
    <title>Loop Hoisting</title>
    <link href="https://gandalfliang.github.io/2019/01/15/loop-hoisting/"/>
    <id>https://gandalfliang.github.io/2019/01/15/loop-hoisting/</id>
    <published>2019-01-14T17:52:23.000Z</published>
    <updated>2021-02-10T03:52:13.743Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>在<a href="https://gandalfliang.github.io/2018/12/26/csharp-memory-model-part-1/">上篇文章</a>中，提到 <code>Loop Hoisting</code> ，这是一个常见的编译器优化项。我们总是能通过汇编代码等低级语言来“窥探”代码实际是怎么“指示”硬件运行的（这边文章不会涉及到详细的汇编内容，但是会用C#反编译后得到的汇编代码来辅助说明）。如果你看过我前面的几篇文章，会发现我用了大量反编译后的汇编代码来辅助说明，毕竟，千言不如实际的“证据”有说服力。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>言归正传，<code>Loop Hoisting</code>，循环提升（粗略的翻译），编译器对循环代码中 <code>loop-invariant</code> 的代码提取出循环体外，防止循环结构内CPU对主存的重复读取。这很好理解，减少 CPU 与主存之间的 <code>IO</code> 次数，能有效提升程序的运行效率。观察下面的例子：  </p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace loop_hoisting</span><br><span class="line">{</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span></span><br><span class="line"><span class="hljs-class">    </span>{</span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            int[] array = <span class="hljs-keyword">new</span> int[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };</span><br><span class="line">            int x = <span class="hljs-number">10</span>;</span><br><span class="line">            int y = <span class="hljs-number">11</span>;</span><br><span class="line"></span><br><span class="line">            LoopHoistTest(array, x, y);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> LoopHoistTest(int[] array, int x, int y)</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                array[i] = x + y;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>很简单的一个例子，遍历列表且赋值。<code>LoopHoistTest</code> 函数的循环判断里，直接读取列表的长度，编译器在碰到这种情况，会对其进行优化，将对列表长度的读取进行提升（Hoist)，在循环体入口处缓存列表长度，并以此为判断依据，也就是说，从汇编代码的角度，循环判断始终去寄存器中读取缓存的列表长度信息，而不是每次都到主存中读取，以此来提到运行效率。另外，<code>x+y</code>很明显也是一段 <code>loop-invariant</code> 代码，相似地，编译器会将 <code>x+y</code> 的值缓存在某个通用寄存器内，并以此做赋值运算。编译器优化后的代码，就相当于：  <p></p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">namespace loop_hoisting</span><br><span class="line">{</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span></span><br><span class="line"><span class="hljs-class">    </span>{</span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            int[] array = <span class="hljs-keyword">new</span> int[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };</span><br><span class="line">            int x = <span class="hljs-number">10</span>;</span><br><span class="line">            int y = <span class="hljs-number">11</span>;</span><br><span class="line"></span><br><span class="line">            LoopHoistTest(array, x, y);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> LoopHoistTest(int[] array, int x, int y)</span><br><span class="line">        {</span><br><span class="line">            int length = array.Length;</span><br><span class="line">            int sum = x+y;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; length; i++)</span><br><span class="line">            {</span><br><span class="line">                array[i] = sum;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>观察汇编代码：<br><img src="/2019/01/15/loop-hoisting/optLoopHoisting_opted.png" class=""><br>第一个红色框选的汇编代码：<p></p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov   ebx,dword ptr [rsi+<span class="hljs-number">8</span>] <span class="hljs-comment">//将rsi寄存器值加上8的偏移量指向的主存中的值复制到ebx通用寄存器</span></span><br></pre></td></tr></tbody></table></figure><br>其中 <code>rsi</code> 寄存器中的值就是主存中 <code>array</code> 的地址，偏移的8位指向 <code>length</code>  字段，这段指令将数值中的长度信息储存在 <code>ebx</code> 通用寄存器中，并且在以后的 <code>cmp</code> 指令中使用，而不是直接与主存中的内容比较。<p></p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea   ebp,[rdx+r8] <span class="hljs-comment">//将 rdx 和 r8 寄存器中的值相加并传送到 ebp 寄存器</span></span><br></pre></td></tr></tbody></table></figure><br>其中，<code>rdx</code> 和 <code>r8</code> 寄存器分别储存着 x 和 y 的值，两者的和被储存在 <code>ebp</code> 寄存器，以后的指令都使用这个寄存器中的值，不再重复计算。  <p></p><p>当然，并不是所有的循环代码都可以被优化，这涉及到 <code>Loop-invariant</code> 条件的判定，我们下篇文章再讲。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在&lt;a href=&quot;https://gandalfliang.github.io/2018/12/26/csharp-memory-model-part-1/&quot;&gt;上篇文章&lt;/a&gt;中，提到 &lt;code&gt;Loop Hoisting&lt;/code&gt; ，这是一个常见的编译器优化项。我们总是能通过汇编代码等低级语言来“窥探”代码实际是怎么“指示”硬件运行的（这边文章不会涉及到详细的汇编内容，但是会用C#反编译后得到的汇编代码来辅助说明）。如果你看过我前面的几篇文章，会发现我用了大量反编译后的汇编代码来辅助说明，毕竟，千言不如实际的“证据”有说服力。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C#" scheme="https://gandalfliang.github.io/tags/C/"/>
    
      <category term="编译器优化" scheme="https://gandalfliang.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="Loop Hoisting" scheme="https://gandalfliang.github.io/tags/Loop-Hoisting/"/>
    
  </entry>
  
  <entry>
    <title>C# 内存模型</title>
    <link href="https://gandalfliang.github.io/2018/12/26/csharp-memory-model-part-1/"/>
    <id>https://gandalfliang.github.io/2018/12/26/csharp-memory-model-part-1/</id>
    <published>2018-12-26T07:43:56.000Z</published>
    <updated>2021-02-10T03:52:13.661Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>在 C# 的语言规范中 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf" target="_blank" rel="noopener">ECMA-334</a>，对于<code>Volatile</code>关键字的描述：</p><blockquote><p><em>15.5.4 Volatile fields<br>When a field-declaration includes a volatile modifier, the fields introduced by that declaration are volatile fields. For non-volatile fields, optimization techniques that reorder instructions can lead to unexpected and unpredictable results in multi-threaded programs that access fields without synchronization such as that provided by the lock-statement (§13.13). These optimizations can be<br>performed by the compiler, by the run-time system, or by hardware. For volatile fields, such reordering optimizations are restricted:</em></p><ul><li><em>A read of a volatile field is called a volatile read. A volatile read has “acquire semantics”; that is, it is guaranteed to occur prior to any references to memory that occur after it in the instruction sequence.</em>  </li><li><em>A write of a volatile field is called a volatile write. A volatile write has “release semantics”; that is, it is guaranteed to happen after any memory references prior to the write instruction in the instruction sequence.</em></li></ul></blockquote><p>简单来说，对于常规字段，由于代码优化而导致指令顺序改变，如果没有进行一定的同步控制，在多线程应用中可能会导致意想不到的结果，而造成这种意外的原因可能是编译器优化、运行时系统的优化或者因为硬件的原因（即CPU和主存储器的通信模型）。可变(volatile)字段会限制这种优化的发生，在这里引入两个定义：</p><ul><li>可变读： 对于可变字段的读操作会<code>获取语义</code>。即，其可以保证对于可变字段的内存读取操作一定发生在其后内存操作指令的前面。进一步解释，与 <strong>Thread.MemoryBarrier</strong> 类似，获取语义会保证在读取可变字段指令前的指令可以跨越它出现在它后面，但是相反地，在它后面的指令不能跨越它出现在它的前面。例子：<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Volatile_class</span></span></span><br><span class="line"><span class="hljs-class"></span>{</span><br><span class="line">    private int _a;</span><br><span class="line">    private volatile int _b;</span><br><span class="line">    private int _c;</span><br><span class="line"></span><br><span class="line">    private <span class="hljs-keyword">void</span> Call()</span><br><span class="line">    {</span><br><span class="line">        int temp=_a;</span><br><span class="line">        <span class="hljs-comment">//由于_b是可变字段，这样可以保证编译器不会将temp2=_c的指令提前到其之前</span></span><br><span class="line">        <span class="hljs-comment">//但是，可以将temp=_a提到其之后</span></span><br><span class="line">        int temp1=_b;</span><br><span class="line">        int temp2=_c;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private <span class="hljs-keyword">void</span> OtherCall(){...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>可变写： 对于可变字段的写操作会<code>释放语义</code>。即，其可以保证对于可变字段的写操作发生在其前面指令执行之后，但是在它之后的指令可以跨域它提前执行。<a id="more"></a><h2 id="X86-X64"><a href="#X86-X64" class="headerlink" title="X86_X64"></a>X86_X64</h2>现代的 x86_x64 CPU 可以保证字段的读写都是 “volatile” 的，即你不会读取到旧的字段值，这是由  CPU 提供保证的。这样看起来好像与上面的描述存在矛盾，如果 CPU 可以保证所有字段的读写都是 <em>volatile</em> ,那为什么还需要在语言层面提供<code>volatile</code>关键字。其实这是两个不同的概念，CPU 从硬件层面上保证了对内存的读写是实时的，你不会读取到 Stale Value ,无论这个字段是常规字段还是可变字段。而语言层面上的 <code>volatile</code> 只是一个关键字，告诉编译器不能对该字段进行 <strong>instruction reorder</strong> 等可能导致多线程读写出现不符合预期结果的优化(暂且这样理解)。</li></ul><p>参考这段代码：</p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span></span><br><span class="line"><span class="hljs-class"></span>{</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">infinity_loop</span></span></span><br><span class="line"><span class="hljs-class">    </span>{</span><br><span class="line">        public bool Terminated;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-keyword">var</span> loop=<span class="hljs-keyword">new</span> infinity_loop();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{</span><br><span class="line">            loop.Terminated=<span class="hljs-literal">true</span>;</span><br><span class="line">        }).Start();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span>(!loop.Terminated);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>使用 dotnet core Release 模式运行这段代码，可以发现它永远也不会退出，分析汇编代码： <p></p><img src="/2018/12/26/csharp-memory-model-part-1/infinity_loop.png" class="">  <p>可以看到红色框选位置，指令<code>test</code>一直在比较<code>eax</code>寄存器上的值，而该寄存器缓存了loop对象的Terminated值（为false)，汇编语言中，<code>test</code>是对两个参数进行<code>AND</code>操作，并设置对应的标志位。例如，如果两个值的<code>AND</code>操作为0，则<code>ZF</code>标志会被设置为1。而<code>je</code>指令是：根据特定标志位的情况进行跳转，其中就包括了<code>ZF</code>标志位。回到上面的汇编代码，可以知道 <code>test eax eax</code> 肯定会将<code>ZF</code>设置为1，则<code>je</code>就会导致死循环的产生。  </p><p>尝试为Terminated值添加<code>volatile</code>关键字  </p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span></span><br><span class="line"><span class="hljs-class"></span>{</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">infinity_loop</span></span></span><br><span class="line"><span class="hljs-class">    </span>{</span><br><span class="line">        public volatile bool Terminated;<span class="hljs-comment">//可变字段</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(string[] args)</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-keyword">var</span> loop=<span class="hljs-keyword">new</span> infinity_loop();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{</span><br><span class="line">            loop.Terminated=<span class="hljs-literal">true</span>;</span><br><span class="line">        }).Start();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span>(!loop.Terminated);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>运行代码，可以发现程序正常退出。再看汇编代码：  <p></p><img src="/2018/12/26/csharp-memory-model-part-1/out_of_infinity_loop.png" class="">  <p>可以看到，这次是直接比较内存中字段的真实值，而不是寄存器上的值，这样循环会正常退出。</p><p>这是因为<code>Loop Hoisting</code>优化策略导致其中的循环判断经过<code>JIT</code>编译器优化后变成如下：</p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(!loop.Terminated)</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);</span><br></pre></td></tr></tbody></table></figure><br>可以想象，这段优化过后的代码在多线程应用中是永远不会退出的。<p></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>volatile 是一个比较晦涩，理解起来可能比较困难的概念，并不建议在不理解的情况下使用，你可以使用<code>lock</code>,<code>Thread.MemoryBarrier</code>或者<code>Interlocked</code>作为替代，不仅仅因为其中有过多的细节对开发人员隐藏，而且还要保证你的团队组员都理解其中的工作原理，特别地，volatile还会受不同环境影响，例如.NET Framework，编译器版本，甚至是硬件实现，这些都是需要考虑的因素。你要在使用 lock(或者其他)导致的性能开销和 <code>volatile</code> 引入导致的代码维护难度这两方面进行权衡。</p><p>参考文章:<br><a href="https://msdn.microsoft.com/en-us/magazine/jj883956.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/magazine/jj883956.aspx</a></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在 C# 的语言规范中 &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMA-334&lt;/a&gt;，对于&lt;code&gt;Volatile&lt;/code&gt;关键字的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;15.5.4 Volatile fields&lt;br&gt;When a field-declaration includes a volatile modifier, the fields introduced by that declaration are volatile fields. For non-volatile fields, optimization techniques that reorder instructions can lead to unexpected and unpredictable results in multi-threaded programs that access fields without synchronization such as that provided by the lock-statement (§13.13). These optimizations can be&lt;br&gt;performed by the compiler, by the run-time system, or by hardware. For volatile fields, such reordering optimizations are restricted:&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;A read of a volatile field is called a volatile read. A volatile read has “acquire semantics”; that is, it is guaranteed to occur prior to any references to memory that occur after it in the instruction sequence.&lt;/em&gt;  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;A write of a volatile field is called a volatile write. A volatile write has “release semantics”; that is, it is guaranteed to happen after any memory references prior to the write instruction in the instruction sequence.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，对于常规字段，由于代码优化而导致指令顺序改变，如果没有进行一定的同步控制，在多线程应用中可能会导致意想不到的结果，而造成这种意外的原因可能是编译器优化、运行时系统的优化或者因为硬件的原因（即CPU和主存储器的通信模型）。可变(volatile)字段会限制这种优化的发生，在这里引入两个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可变读： 对于可变字段的读操作会&lt;code&gt;获取语义&lt;/code&gt;。即，其可以保证对于可变字段的内存读取操作一定发生在其后内存操作指令的前面。进一步解释，与 &lt;strong&gt;Thread.MemoryBarrier&lt;/strong&gt; 类似，获取语义会保证在读取可变字段指令前的指令可以跨越它出现在它后面，但是相反地，在它后面的指令不能跨越它出现在它的前面。例子：&lt;epacse hidden=&quot;&quot;&gt;4&lt;/epacse&gt;&lt;/li&gt;
&lt;li&gt;可变写： 对于可变字段的写操作会&lt;code&gt;释放语义&lt;/code&gt;。即，其可以保证对于可变字段的写操作发生在其前面指令执行之后，但是在它之后的指令可以跨域它提前执行。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C#" scheme="https://gandalfliang.github.io/tags/C/"/>
    
      <category term="Volatile" scheme="https://gandalfliang.github.io/tags/Volatile/"/>
    
      <category term="内存模型" scheme="https://gandalfliang.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C# 尾递归优化</title>
    <link href="https://gandalfliang.github.io/2018/08/23/tail-recursion/"/>
    <id>https://gandalfliang.github.io/2018/08/23/tail-recursion/</id>
    <published>2018-08-22T16:41:31.000Z</published>
    <updated>2021-02-10T03:52:13.754Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="何为尾递归"><a href="#何为尾递归" class="headerlink" title="何为尾递归"></a><strong>何为尾递归</strong></h2><p>有时候我们使用递归来解决一些特定的问题，但是使用递归需要注意不要导致栈溢出，这是使用递归的一个常见问题，对于规模足够大的问题，使用递归必定会导致栈溢出。通常，我们可以通过尾递归进行优化，尾递归可以避免栈溢出的问题（暂且这样认为）。<br>尾递归并不是什么新奇的东西，理解起来很简单，对于递归，如果上层调用的返回结果不依赖子调用的结果，那么，这就是一个尾递归。例如：</p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">///这是一个简单的尾递归例子</span></span><br><span class="line">namespace tail</span><br><span class="line">{</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span></span><br><span class="line"><span class="hljs-class">    </span>{</span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-keyword">var</span> test=RetrieveData(<span class="hljs-number">100000000000000</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">static</span> long RetrieveData(long unit)</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-keyword">if</span> (unit == <span class="hljs-number">0</span>)</span><br><span class="line">                <span class="hljs-keyword">return</span> unit;</span><br><span class="line">            <span class="hljs-keyword">return</span> RetrieveData(--unit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="等等，好像有什么地方不对"><a href="#等等，好像有什么地方不对" class="headerlink" title="等等，好像有什么地方不对"></a><strong>等等，好像有什么地方不对</strong></h2><p>从上面的例子分析，代码依旧会导致栈溢出，不是吗？是的，聪明的你答对了。那为什么说尾递归可以避免栈溢出问题？当然，从刚才的结论看，这个问题提的并不准确，尾递归并不能避免栈溢出问题。<br>仔细想想，尾递归结构和循环结构是类似的，上面的尾递归可以写成：<br><a id="more"></a></p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//糟糕的例子，但是就这样吧</span></span><br><span class="line"><span class="hljs-keyword">static</span> long RetriveData(long unit)</span><br><span class="line">{</span><br><span class="line">    <span class="hljs-keyword">for</span>(long i=unit;i&lt;=<span class="hljs-number">0</span>;i--)</span><br><span class="line">        <span class="hljs-keyword">continue</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>请忽略这个蠢函数什么都不做的事实。回到问题上，循环结构并不会导致栈溢出，基于这种结构上的对应，编译器可以对尾递归进行优化，重复使用栈上的递归函数，而不是每次调用都进行压栈操作，以此来避免栈溢出的问题。所以，完善的结论是：通过编译器优化，尾递归可以避免栈溢出的问题。  <p></p><h2 id="那么C-呢？"><a href="#那么C-呢？" class="headerlink" title="那么C#呢？"></a><strong>那么C#呢？</strong></h2><p>不幸的是，对于微软的 C# Compiler， 只有 <code>x64 Release</code> 才有尾递归优化。作为对比，我们分析其与 <code>x86 Release</code> 下编译后的代码的区别，看看编译器是如何优化尾递归调用的。 </p><img src="/2018/08/23/tail-recursion/IL_x86.png" class="" title="IL-x86">    <img src="/2018/08/23/tail-recursion/IL_x64.png" class="" title="IL-x64">    <p>分析两者的 <code>IL</code> 代码，可以发现它们并没有什么区别，所以，真正进行优化操作的是 <code>JIT</code> 编译器。<br>分析两者的汇编代码：  </p><img src="/2018/08/23/tail-recursion/ASM_x86.png" class="" title="ASM-x86">    <img src="/2018/08/23/tail-recursion/ASM_x64.png" class="" title="ASM-x64">    <p>可以看出，在 <code>ASM_x64</code> 中，递归调用没有重复压栈，而是在栈内跳转，类似于循环结构，以此来避免栈溢出问题。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;何为尾递归&quot;&gt;&lt;a href=&quot;#何为尾递归&quot; class=&quot;headerlink&quot; title=&quot;何为尾递归&quot;&gt;&lt;/a&gt;&lt;strong&gt;何为尾递归&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;有时候我们使用递归来解决一些特定的问题，但是使用递归需要注意不要导致栈溢出，这是使用递归的一个常见问题，对于规模足够大的问题，使用递归必定会导致栈溢出。通常，我们可以通过尾递归进行优化，尾递归可以避免栈溢出的问题（暂且这样认为）。&lt;br&gt;尾递归并不是什么新奇的东西，理解起来很简单，对于递归，如果上层调用的返回结果不依赖子调用的结果，那么，这就是一个尾递归。例如：&lt;/p&gt;
&lt;p&gt;&lt;epacse hidden=&quot;&quot;&gt;10&lt;/epacse&gt;&lt;/p&gt;
&lt;h2 id=&quot;等等，好像有什么地方不对&quot;&gt;&lt;a href=&quot;#等等，好像有什么地方不对&quot; class=&quot;headerlink&quot; title=&quot;等等，好像有什么地方不对&quot;&gt;&lt;/a&gt;&lt;strong&gt;等等，好像有什么地方不对&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;从上面的例子分析，代码依旧会导致栈溢出，不是吗？是的，聪明的你答对了。那为什么说尾递归可以避免栈溢出问题？当然，从刚才的结论看，这个问题提的并不准确，尾递归并不能避免栈溢出问题。&lt;br&gt;仔细想想，尾递归结构和循环结构是类似的，上面的尾递归可以写成：&lt;br&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C#" scheme="https://gandalfliang.github.io/tags/C/"/>
    
      <category term="尾递归" scheme="https://gandalfliang.github.io/tags/%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>业务逻辑中的 Filter</title>
    <link href="https://gandalfliang.github.io/2018/07/16/filtering-in-business-logic/"/>
    <id>https://gandalfliang.github.io/2018/07/16/filtering-in-business-logic/</id>
    <published>2018-07-16T03:50:00.000Z</published>
    <updated>2021-02-10T03:52:13.718Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="Pipe-and-Filter"><a href="#Pipe-and-Filter" class="headerlink" title="Pipe and Filter"></a>Pipe and Filter</h2><p>在一些应用的开发场景中，例如，大量的数据处理、需要对数据进行大量的转换和过滤，使用管道和<code>Filter</code>是一个很好的选择。对于这种应用场景，一般都需要处理业务足够灵活，并且足够健壮。想象一下，为了实现相应的过滤功能，使用大量的<code>if</code>或者<code>switch case</code>,日后维护这套代码的人估计也会抓狂的吧，单元测试编写起来，应该也够呛吧。<br><a id="more"></a></p><h2 id="用Filter来处理业务"><a href="#用Filter来处理业务" class="headerlink" title="用Filter来处理业务"></a>用<code>Filter</code>来处理业务</h2><p>Filter一般都被认为是用来处理数据的，其实，更近一步，用来”处理”业务，也不失为一种好办法。当然，这里的处理，并不是说在Filter中执行业务，考虑到业务都是一些耗时（但不绝对）的操作，在管道中处理业务是不对的，这样会堵塞整条管道。相反地，我们的业务依赖管道中的数据，我们希望在数据处理的过程中，由数据的处理来触发特定的业务，因此，我们定义一种BusinessFilter，其不对数据进行处理，而是作为一种窥探，“假装”自己是在进行数据处理，实际是根据数据的实际来通知外界做相应的业务而已。<br><img src="/2018/07/16/filtering-in-business-logic/pipe.png" class="">  </p><h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p>正如上图的结构，搭积木式的链式结构可以根据业务的调整进行对应的调整，不同的业务可以在通道中穿插。从另一个方面可以看出，我们设计Filter的时候，保持它的独立性是至关重要的，一个Filter完成一个工作，而且不受其他Filter影响是保持整个链式结构灵活的关键。</p><h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><p>一般来说，管道/Filter结构一旦确定，会做大调整的几率都不高。由于Filter的存在，所有的变动在改动之前就可以确定影响范围，而且可以限制调整带来的结构变动。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul><li>几乎所有的Pipe/Filter结构都是线性结构，这种情况限制了async/await的应用</li><li>如果一个Filter只接受一种数据类型，那么存在的数据转换会降低我们系统的性能，特别地，如果是C#，进行引用类型和值类型的转换，频繁的装箱拆箱也会降低我们系统的性能；为了解决这种问题，限制Filter可接受的数据类型，这样就不能随意连接Filter到所有数据类型，通用性降低。</li><li>…</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;Pipe-and-Filter&quot;&gt;&lt;a href=&quot;#Pipe-and-Filter&quot; class=&quot;headerlink&quot; title=&quot;Pipe and Filter&quot;&gt;&lt;/a&gt;Pipe and Filter&lt;/h2&gt;&lt;p&gt;在一些应用的开发场景中，例如，大量的数据处理、需要对数据进行大量的转换和过滤，使用管道和&lt;code&gt;Filter&lt;/code&gt;是一个很好的选择。对于这种应用场景，一般都需要处理业务足够灵活，并且足够健壮。想象一下，为了实现相应的过滤功能，使用大量的&lt;code&gt;if&lt;/code&gt;或者&lt;code&gt;switch case&lt;/code&gt;,日后维护这套代码的人估计也会抓狂的吧，单元测试编写起来，应该也够呛吧。&lt;br&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="design pattern" scheme="https://gandalfliang.github.io/tags/design-pattern/"/>
    
      <category term="filter" scheme="https://gandalfliang.github.io/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>使用 IDE 编译调试 Mlt framework</title>
    <link href="https://gandalfliang.github.io/2018/06/01/debugging-mlt/"/>
    <id>https://gandalfliang.github.io/2018/06/01/debugging-mlt/</id>
    <published>2018-06-01T05:32:41.000Z</published>
    <updated>2021-02-10T03:52:13.705Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p><a href="https://www.mltframework.org/" target="_blank" rel="noopener"><code>Mlt framework</code></a> 是一个开源跨平台的多媒体处理框架，使用模块化的设计，集成了大量的业界领先的视频处理框架，如ffmpeg，良好的设计，可以方便的集成自己的模块进去，利用它，你可以实现自己的 Adobe Premiere 等非线性多媒体编辑软件或者视频播放器，简单几句代码为视频添加炫酷的转场效果和滤镜。 </p><p>由于跨平台，项目通过configure的方式来管理工程，对于学习来说多媒体框架来说，调试起来并不方便，我整理了CMake的脚本，可以通过cmake来生成我们熟悉的 Visual Studio 或者 Xcode<br>工程，方便调试。  </p><p>在阅读下面文章之前，请确保你有一定的 MinGW 工具链使用经验。<br><a id="more"></a></p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p><a href="https://github.com/gandalfliang/mlt" target="_blank" rel="noopener">https://github.com/gandalfliang/mlt</a><br>分支：cmake</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>对于 Windows 平台：  </p><ol><li>cmake</li><li>MinGW </li><li>msys2</li><li>Windows SDK  </li></ol><p>确保MinGW和msys2里的工具链路径在系统变量PATH中</p><p>Mac 平台：</p><ol><li>Xcode  </li></ol><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>在工程跟目录，运行脚本（如果是 Windows 平台，从开发者命令行工具运行）：  </p><p></p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py bootstrap.py</span><br></pre></td></tr></tbody></table></figure><br>如果一切顺利，工程文件将会在 <code>build/win32</code> 或者 <code>build/mac</code> 下。脚本运行要拉取ffmpeg的源码并configure，这是一个耗时的工作。在Windows平台下configure ffmpeg将是一个漫长的等待，没事的话，去喝杯咖啡，或者有空的时候在命令窗里敲一下enter键，可能会有收获哦。<p></p><p>完成后，你就可以愉快的调试这个框架了。 </p><img src="/2018/06/01/debugging-mlt/mac.png" class=""></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;a href=&quot;https://www.mltframework.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Mlt framework&lt;/code&gt;&lt;/a&gt; 是一个开源跨平台的多媒体处理框架，使用模块化的设计，集成了大量的业界领先的视频处理框架，如ffmpeg，良好的设计，可以方便的集成自己的模块进去，利用它，你可以实现自己的 Adobe Premiere 等非线性多媒体编辑软件或者视频播放器，简单几句代码为视频添加炫酷的转场效果和滤镜。 &lt;/p&gt;
&lt;p&gt;由于跨平台，项目通过configure的方式来管理工程，对于学习来说多媒体框架来说，调试起来并不方便，我整理了CMake的脚本，可以通过cmake来生成我们熟悉的 Visual Studio 或者 Xcode&lt;br&gt;工程，方便调试。  &lt;/p&gt;
&lt;p&gt;在阅读下面文章之前，请确保你有一定的 MinGW 工具链使用经验。&lt;br&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Visual Studio" scheme="https://gandalfliang.github.io/tags/Visual-Studio/"/>
    
      <category term="Mlt Framework" scheme="https://gandalfliang.github.io/tags/Mlt-Framework/"/>
    
      <category term="Xcode" scheme="https://gandalfliang.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Debug Mlt Framework in VSCode</title>
    <link href="https://gandalfliang.github.io/2018/04/17/debug_mlt_vscode/"/>
    <id>https://gandalfliang.github.io/2018/04/17/debug_mlt_vscode/</id>
    <published>2018-04-16T17:21:38.000Z</published>
    <updated>2021-02-10T03:52:13.671Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="Debugging-Mlt-framework-in-VSCode"><a href="#Debugging-Mlt-framework-in-VSCode" class="headerlink" title="Debugging Mlt framework in VSCode"></a><code>Debugging Mlt framework in VSCode</code></h2><img src="/2018/04/17/debug_mlt_vscode/mlt_vscode.png" class=""><p>Crossing platform with built in tool chain</p><img src="/2018/04/17/debug_mlt_vscode/mlt_vscode_osx.png" class="">  <p>Coming up soon (maybe)</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;Debugging-Mlt-framework-in-VSCode&quot;&gt;&lt;a href=&quot;#Debugging-Mlt-framework-in-VSCode&quot; class=&quot;headerlink&quot; title=&quot;D
      
    
    </summary>
    
      <category term="图片" scheme="https://gandalfliang.github.io/categories/%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="VSCode" scheme="https://gandalfliang.github.io/tags/VSCode/"/>
    
      <category term="Mlt Framework" scheme="https://gandalfliang.github.io/tags/Mlt-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Gitsoler</title>
    <link href="https://gandalfliang.github.io/2018/03/21/Gitsoler1_1/"/>
    <id>https://gandalfliang.github.io/2018/03/21/Gitsoler1_1/</id>
    <published>2018-03-21T03:01:38.000Z</published>
    <updated>2018-03-21T12:58:07.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gitsoler-1-1-Split-View-supported-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler"><a href="#Gitsoler-1-1-Split-View-supported-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler" class="headerlink" title="Gitsoler 1.1 - Split View supported: https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler"></a>Gitsoler 1.1 - Split View supported: <a href="https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gitsoler-1-1-Split-View-supported-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler&quot;&gt;&lt;a href=&quot;#Gitsoler-1-1-Sp
      
    
    </summary>
    
      <category term="工具" scheme="https://gandalfliang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Visual Studio" scheme="https://gandalfliang.github.io/tags/Visual-Studio/"/>
    
      <category term="Extension" scheme="https://gandalfliang.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】关于 WPF 透明窗口的内存占用</title>
    <link href="https://gandalfliang.github.io/2018/02/16/transparent_4k_window.translate/"/>
    <id>https://gandalfliang.github.io/2018/02/16/transparent_4k_window.translate/</id>
    <published>2018-02-16T15:01:38.000Z</published>
    <updated>2018-05-28T10:38:02.459Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自己的文章才是最骚的。。。  <a href="https://gandalfliang.github.io/2018/01/17/transparent_4k_window/">Origin Post</a></p><hr><p>要实现一个透明的 WPF 窗口？<br>多么简单的一个任务啊！只要设置 AllowTransparency 和 WindowStyle，你可以在毫秒间完成这个任务。  </p><p><code>AllowTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Background=&quot;Transparent&quot;</code>   </p><p>正确吧？当然。<br>但是（你懂得），打开你的任务管理器看看，简单的任务通常会带来大量的内存占用，特别是4K分辨率的透明窗口。100+ MB的内存被浪费了，就只为了显示一个空白的透明窗口！这是不可接受的。一年前，如果你说：”谁关心内存呀，现在的内存条太便宜了”，你可能是对的。但是查查这一年内存条的价格走向，它们现在贵上天了。</p><h2 id="WPF-透明窗口的有趣小真相"><a href="#WPF-透明窗口的有趣小真相" class="headerlink" title="WPF 透明窗口的有趣小真相"></a>WPF 透明窗口的有趣小真相</h2><ul><li><code>内存占用随着窗口尺寸增大而增加</code></li><li><code>Win32 窗口没有这样的问题</code>  </li></ul><p>等等，什么？窗口越大，内存消耗的更多？嗯。。。这看起来很熟悉嘛，就像一个<code>Bitmap</code>。知道现在，我们并不知道 WPF 是如何处理透明窗口的，但是这种症状显示它就好像直接将整个桌面作为一个位图，然后窗口用这张位图的重叠部分作为其背景来更新自己，让它看起来是“透明”的。多么聪明的做法呀。。。<br>在 WPF 刚刚发布的那些日子里，低分辨率的计算机屏幕占据主流位置，即使在今天，大多数的笔记本电脑依然带着一块1366*768分辨率的屏幕被推向市场（离谱吧）。让我们唾弃那些OEM厂商讲的毫无根据的废话并且思考一下运行在高分辨率下的程序的情况。  </p><h2 id="内存并不是免费的，不要浪费之"><a href="#内存并不是免费的，不要浪费之" class="headerlink" title="内存并不是免费的，不要浪费之"></a>内存并不是免费的，不要浪费之</h2><p>很显然，浪费100+MB的内存来显示一个4K的透明窗口是不可接受的，特别是和 Win32 窗口只占用10+MB的内存进行比较时。这差距让 WPF 看起来蠢透了。<br>抱怨已经够多了，想想对此我们能做什么呢？我可不想用C++和GDI将我的UI代码重写一遍，这太没效率并且也跟不上时代，况且，没人会为此“区区小事”去放弃他们漂亮、易于维护的Xaml UI代码。  </p><h2 id="使用-Win32-承载-WPF-内容"><a href="#使用-Win32-承载-WPF-内容" class="headerlink" title="使用 Win32 承载 WPF 内容"></a>使用 Win32 承载 WPF 内容</h2><p>好吧，确实，没人愿意为了区区90MB内存去重写它们的UI。与使用C++重写UI所耗费的精力相比，这个内存的占用差距看起来是可以接受的（#笑脸）。但是请记住，我们一如既往的可以在 Win32 窗口中承载 WPF 的内容。<br>例如，我们想创建一个全屏、半透明背景带着非透明内容的对话框。为了规避 WPF 透明窗口的内存问题，我们可以使用 Win32 创建一个半透明的窗口：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DWORD Flags1 = WS_EX_LAYERED;</span><br><span class="line">DWORD Flags2 = WS_POPUP;</span><br><span class="line"></span><br><span class="line">HWND hWnd = CreateWindowEx(Flags1,szWindowClass, szTitle, Flags2,</span><br><span class="line">    CW_USEDEFAULT, <span class="number">0</span>, <span class="number">3840</span>,<span class="number">2160</span>, nullptr, nullptr, hInstance, nullptr);</span><br><span class="line"></span><br><span class="line">SetLayeredWindowAttributes(hWnd, RRR, (BYTE)<span class="number">125</span>, LWA_ALPHA);</span><br><span class="line">ShowWindow(hWnd, nCmdShow);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_ERASEBKGND:</span><br><span class="line">    RECT rect;</span><br><span class="line">    GetClientRect(hWnd, &amp;rect);</span><br><span class="line">    FillRect((HDC)wParam, &amp;rect, CreateSolidBrush(RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>通过启用 <code>C++/CLI</code>，我们可以直接访问 WPF 内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace ManagedCode</span><br><span class="line">&#123;</span><br><span class="line">    using namespace System;</span><br><span class="line">    using namespace System::Windows;</span><br><span class="line">    using namespace System::Windows::Interop;</span><br><span class="line">    using namespace System::Windows::Media;</span><br><span class="line"></span><br><span class="line">    HWND GetHwnd(HWND parent, int x, int y, int width, int height) &#123;</span><br><span class="line">    HwndSource^ source = gcnew HwndSource(</span><br><span class="line">        <span class="number">0</span>, <span class="comment">// class style  </span></span><br><span class="line">        WS_VISIBLE | WS_CHILD, <span class="comment">// style  </span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// exstyle  </span></span><br><span class="line">        x, y, width, height,</span><br><span class="line">        <span class="string">"hi"</span>, <span class="comment">// NAME  </span></span><br><span class="line">        IntPtr(parent)        <span class="comment">// parent window   </span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    UIElement^ page = gcnew ManagedContent::WPFContent();</span><br><span class="line">    source-&gt;RootVisual = page;</span><br><span class="line">    <span class="keyword">return</span> (HWND)source-&gt;Handle.ToPointer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//managed content</span></span><br><span class="line">ManagedCode::GetHwnd(hWnd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>由于 WPF 和 GDI 背后的技术不尽相同，还有更多的工作需要做来解决不可避免的透明通道问题，但是，为了方便，你始终可以使用 Popup 来实现你的目标。</p><hr><p>Macbook Pro 2016 的键盘真垃圾。。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;翻译自己的文章才是最骚的。。。  &lt;a href=&quot;https://gandalfliang.github.io/2018/01/17/transparent_4k_window/&quot;&gt;Origin Post&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;要实现一个透明的 WPF 窗口？&lt;
      
    
    </summary>
    
      <category term="翻译" scheme="https://gandalfliang.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="翻译" scheme="https://gandalfliang.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="LayeredWindow" scheme="https://gandalfliang.github.io/tags/LayeredWindow/"/>
    
      <category term="Performance" scheme="https://gandalfliang.github.io/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>Light Weighted DropshadowEffect</title>
    <link href="https://gandalfliang.github.io/2018/02/12/lightweighted_shadoweffect/"/>
    <id>https://gandalfliang.github.io/2018/02/12/lightweighted_shadoweffect/</id>
    <published>2018-02-12T05:58:27.000Z</published>
    <updated>2018-05-28T10:38:02.453Z</updated>
    
    <content type="html"><![CDATA[<p>Let’s create a light weighted wpf drop shadow effect, considering that the origin one performs badly in some special occasions.<br>As I mentioned before (<a href="https://gandalfliang.github.io/2017/09/20/WPF_rendering_perf/">check it out</a>), the original WPF DropShadow Effect can cause severe preformance problem. Due to the “flaw” M$FT brought to the HLSL support for WPF, the Effect class that implements the visual effect creates and destroy GPU resource each frame, which is the worst thing you could do with GPU resources. So, what about implementing a custom shadow effect to avoid it? This sounds interesting.  </p><p>– 春节补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Let’s create a light weighted wpf drop shadow effect, considering that the origin one performs badly in some special occasions.&lt;br&gt;As I m
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="OpenCL" scheme="https://gandalfliang.github.io/tags/OpenCL/"/>
    
      <category term="高性能计算" scheme="https://gandalfliang.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="图像处理" scheme="https://gandalfliang.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>关于 WPF 透明窗口的内存占用</title>
    <link href="https://gandalfliang.github.io/2018/01/17/transparent_4k_window/"/>
    <id>https://gandalfliang.github.io/2018/01/17/transparent_4k_window/</id>
    <published>2018-01-17T03:01:38.000Z</published>
    <updated>2018-02-12T07:24:25.848Z</updated>
    
    <content type="html"><![CDATA[<p>要实现一个透明的 WPF 窗口？<br>What an easy task! By setting AllowTransparency and WindowStyle, you could finish it in seconds.   </p><p><code>AllowTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Background=&quot;Transparent&quot;</code>   </p><p>Correct? Of course.  </p><p>However (you know this is coming), look at your task manager, easy task comes with large memory consumption, especially for 4K transparent window. 100+ MB ram are wasted for just showing an empty, transparent window! That’s unacceptable. A year ago, you might be right saying “Who cares about RAM, they are cheap as hell”, but check out the price they’ve grown over this year, they are expensive as hell now.  </p><h2 id="Fun-fact-of-WPF-transparent-window"><a href="#Fun-fact-of-WPF-transparent-window" class="headerlink" title="Fun fact of WPF transparent window"></a>Fun fact of WPF transparent window</h2><ul><li><code>RAM usage increase as window size enlarge</code>  </li><li><code>Win32 window has no such problem</code>  </li></ul><p>Wait, what? The larger the window is, the more RAM it consumes? Hmmmmm… this looks familiar, just like a <code>Bitmap</code>. For now, we don’t know how WPF handles transparent window, but the symptom shows that it’s like using the whole screen as a bitmap and the window updating itself with portion of that bitmap, making it “transparent”. What a smart move…<br>Back in the days when WPF was first released, low screen resolution was the main stream. Even today, most laptops still are shipping with a monitor of 1366*768 (ridiculous, right?). Let’s despise the nonsense the OEM told us and think about program running in computers with higher screen resolution. </p><h2 id="RAM-is-not-free-do-not-waste-it"><a href="#RAM-is-not-free-do-not-waste-it" class="headerlink" title="RAM is not free, do not waste it"></a>RAM is not free, do not waste it</h2><p>Obviously, costing 100+ mb of ram for showing a transparent window in 4K is unacceptable, especially compared with Win32 transparent window, which costs only 10+ mb. The gap between them makes WPF look dump.<br>Enough complaining, what can we do about it? I don’t want to write UI code with GDI using C++, that’s inefficient and not modern, plus, no one would abandon their beautiful, easy to maintain xaml UI code for this.</p><h2 id="Hosting-WPF-content-in-Win32-Window"><a href="#Hosting-WPF-content-in-Win32-Window" class="headerlink" title="Hosting WPF content in Win32 Window"></a>Hosting WPF content in Win32 Window</h2><p>Well, indeed, no one would rewrite their UI code for just about 90mb of RAM. Compared with the work needed to rewrite C++ UI code, the RAM consumption gap seems acceptable (#smile face). But please remember, we can always host WPF content in win32 window.<br>Let say, we want to create a full screen notification dialog with semi-transparent background and apaque notication content in the center. To avoid the WPF ram problem, we create a semi-transparent window using win32:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DWORD Flags1 = WS_EX_LAYERED;</span><br><span class="line">DWORD Flags2 = WS_POPUP;</span><br><span class="line"></span><br><span class="line">HWND hWnd = CreateWindowEx(Flags1,szWindowClass, szTitle, Flags2,</span><br><span class="line">    CW_USEDEFAULT, <span class="number">0</span>, <span class="number">3840</span>,<span class="number">2160</span>, nullptr, nullptr, hInstance, nullptr);</span><br><span class="line"></span><br><span class="line">SetLayeredWindowAttributes(hWnd, RRR, (BYTE)<span class="number">125</span>, LWA_ALPHA);</span><br><span class="line">ShowWindow(hWnd, nCmdShow);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_ERASEBKGND:</span><br><span class="line">    RECT rect;</span><br><span class="line">    GetClientRect(hWnd, &amp;rect);</span><br><span class="line">    FillRect((HDC)wParam, &amp;rect, CreateSolidBrush(RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>By enabling <code>C++/CLI</code>, we can access WPF content directly  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace ManagedCode</span><br><span class="line">&#123;</span><br><span class="line">    using namespace System;</span><br><span class="line">    using namespace System::Windows;</span><br><span class="line">    using namespace System::Windows::Interop;</span><br><span class="line">    using namespace System::Windows::Media;</span><br><span class="line"></span><br><span class="line">    HWND GetHwnd(HWND parent, int x, int y, int width, int height) &#123;</span><br><span class="line">    HwndSource^ source = gcnew HwndSource(</span><br><span class="line">        <span class="number">0</span>, <span class="comment">// class style  </span></span><br><span class="line">        WS_VISIBLE | WS_CHILD, <span class="comment">// style  </span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// exstyle  </span></span><br><span class="line">        x, y, width, height,</span><br><span class="line">        <span class="string">"hi"</span>, <span class="comment">// NAME  </span></span><br><span class="line">        IntPtr(parent)        <span class="comment">// parent window   </span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    UIElement^ page = gcnew ManagedContent::WPFContent();</span><br><span class="line">    source-&gt;RootVisual = page;</span><br><span class="line">    <span class="keyword">return</span> (HWND)source-&gt;Handle.ToPointer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and finally  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//managed content</span></span><br><span class="line">ManagedCode::GetHwnd(hWnd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>Due to the different technologies behind WPF and GDI, more work needed to be done for the unavoidable alpha blending problem, but, you can use wpf popup to achieve your goal for short. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要实现一个透明的 WPF 窗口？&lt;br&gt;What an easy task! By setting AllowTransparency and WindowStyle, you could finish it in seconds.   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Allo
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="LayeredWindow" scheme="https://gandalfliang.github.io/tags/LayeredWindow/"/>
    
      <category term="Performance" scheme="https://gandalfliang.github.io/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenCL 实现图片高斯模糊</title>
    <link href="https://gandalfliang.github.io/2018/01/02/gaussian_blur_opencl/"/>
    <id>https://gandalfliang.github.io/2018/01/02/gaussian_blur_opencl/</id>
    <published>2018-01-02T05:58:27.000Z</published>
    <updated>2021-02-10T03:52:13.726Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>高斯模糊（ <a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A</a> ）是一种常见的图像处理算法，使用高斯分布与图像做卷积，得到模糊的效果。其二维定义：<br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c36071d89adc2f4da470b45ce05c33ca93744577" alt=""> </p><p>σ是正态分布的标准偏差。在应用的时候，假设σ为2.5。对于模糊半径为1，则高斯矩阵为3*3的一个矩阵，以[1,1]为中心，带入公式计算高斯矩阵的值，得到：<br><a id="more"></a><br>||||<br>————|————–|———–<br>0.0216996633|0.0235069655|0.0216996633<br>0.0235069655|0.0254647918|0.0235069655<br>0.0216996633|0.0235069655|0.0216996633  </p><p>他们的和为 0.206291318，我们需要他们的和为1，因此与总和相除得到：  </p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0.105189413</td><td>0.113950342</td><td>0.105189413  </td></tr><tr><td>0.113950342</td><td>0.123440929</td><td>0.113950342  </td></tr><tr><td>0.105189413</td><td>0.113950342</td><td>0.105189413  </td></tr></tbody></table><p>根据这个矩阵，对图像的每个像素点进行计算，计算的九个点的各rgb分量之和就是最终像素的rgb分量。  </p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//计算高斯矩阵</span></span><br><span class="line">private <span class="hljs-keyword">void</span> ComputeWeightMatrix()</span><br><span class="line">{</span><br><span class="line">    <span class="hljs-keyword">var</span> center = Radius;</span><br><span class="line">    <span class="hljs-keyword">var</span> conBase = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.Pow(Variance, <span class="hljs-number">2</span>);</span><br><span class="line">    <span class="hljs-keyword">var</span> conRoot = <span class="hljs-number">1</span> / (<span class="hljs-built_in">Math</span>.PI * conBase);</span><br><span class="line"></span><br><span class="line">    float sum = <span class="hljs-number">0</span>f;</span><br><span class="line">    <span class="hljs-keyword">for</span> (int x = -Radius; x &lt;= Radius; x++)</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-keyword">for</span> (int y = Radius; y &gt;= -Radius; y--)</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-keyword">var</span> weight = conRoot * <span class="hljs-built_in">Math</span>.Pow(<span class="hljs-built_in">Math</span>.E, -(x * x + y * y) / conBase);</span><br><span class="line">            _matrix[GridPosToArrayIndex(x, y, center, Radius)] = (float)weight;</span><br><span class="line">            sum += (float)weight;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; _matrix.Length; i++)</span><br><span class="line">    {</span><br><span class="line">        _matrix[i] /= sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Compute</span></span><br><span class="line">public <span class="hljs-keyword">void</span> Compute(string imageFile)</span><br><span class="line">{</span><br><span class="line">    using (<span class="hljs-keyword">var</span> bitmap = <span class="hljs-keyword">new</span> Bitmap(imageFile))</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-keyword">var</span> datas = bitmap.LockBits(<span class="hljs-keyword">new</span> Rectangle(<span class="hljs-keyword">new</span> Point(), <span class="hljs-keyword">new</span> Size(bitmap.Width, bitmap.Height)),ImageLockMode.ReadOnly,bitmap.PixelFormat);</span><br><span class="line">        <span class="hljs-keyword">var</span> dataSize = datas.Stride * datas.Height;</span><br><span class="line">        <span class="hljs-keyword">var</span> argbs = <span class="hljs-keyword">new</span> byte[dataSize];</span><br><span class="line">        <span class="hljs-keyword">var</span> dsts = <span class="hljs-keyword">new</span> byte[dataSize];</span><br><span class="line">        int matrixWidth = Radius * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;</span><br><span class="line">        Marshal.Copy(datas.Scan0, argbs, <span class="hljs-number">0</span>, dataSize);</span><br><span class="line"></span><br><span class="line">        Stopwatch sw=Stopwatch.StartNew();</span><br><span class="line">        <span class="hljs-keyword">for</span> (int y = <span class="hljs-number">0</span>; y &lt; bitmap.Height; y++)</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-keyword">for</span> (int x = <span class="hljs-number">0</span>; x &lt; bitmap.Width; x++)</span><br><span class="line">            {</span><br><span class="line">                float sumA = <span class="hljs-number">0</span>;</span><br><span class="line">                float sumR = <span class="hljs-number">0</span>;</span><br><span class="line">                float sumG = <span class="hljs-number">0</span>;</span><br><span class="line">                float sumB=<span class="hljs-number">0</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; _matrix.Length; i++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="hljs-keyword">var</span> pos = transform_pos(x, y, matrixWidth, bitmap.Width, bitmap.Height, Radius, i);</span><br><span class="line">                    <span class="hljs-keyword">var</span> position = pos.Y * datas.Stride + pos.X*<span class="hljs-number">4</span>;</span><br><span class="line">                    sumR += argbs[position] * _matrix[i];</span><br><span class="line">                    sumG += argbs[position + <span class="hljs-number">1</span>] * _matrix[i];</span><br><span class="line">                    sumB += argbs[position + <span class="hljs-number">2</span>] * _matrix[i];</span><br><span class="line">                    sumA += argbs[position + <span class="hljs-number">3</span>] * _matrix[i];</span><br><span class="line">                }</span><br><span class="line">                <span class="hljs-keyword">var</span> dstPos = y * datas.Stride + x * <span class="hljs-number">4</span>;</span><br><span class="line">                dsts[dstPos] = (byte)sumR;</span><br><span class="line">                dsts[dstPos+<span class="hljs-number">1</span>] = (byte)sumG;</span><br><span class="line">                dsts[dstPos+<span class="hljs-number">2</span>] = (byte)sumB;</span><br><span class="line">                dsts[dstPos+<span class="hljs-number">3</span>] = (byte)sumA;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        bitmap.UnlockBits(datas);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">var</span> elapse = sw.Elapsed;</span><br><span class="line">        Console.WriteLine($<span class="hljs-string">"Costing: {elapse}"</span>);</span><br><span class="line">        Debug.WriteLine($<span class="hljs-string">"Costing: {elapse}"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">var</span> handle = GCHandle.Alloc(dsts, GCHandleType.Pinned);</span><br><span class="line">        using (<span class="hljs-keyword">var</span> dstBmp = <span class="hljs-keyword">new</span> Bitmap(datas.Width, datas.Height, datas.Stride, bitmap.PixelFormat,</span><br><span class="line">            handle.AddrOfPinnedObject()))</span><br><span class="line">        {</span><br><span class="line">            dstBmp.Save(<span class="hljs-string">"processed_normal.bmp"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        handle.Free();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当然，这样能完成工作，但是耗时太长，对于3000*1920尺寸的图片处理需要2分51秒（Intel Core i7-4770)，这显然是不可接受的。<br>对于这种分别计算每个像素，且各像素间互不干扰的问题，使用OpenCL可以大幅降低时间消耗。  </p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">    OpenCL 高斯模糊代码</span></span><br><span class="line"><span class="hljs-comment">    Copyright Gandalfliang</span></span><br><span class="line"><span class="hljs-comment">*/</span> </span><br><span class="line">inline int2 transform_pos(int centerX,int centerY,int matrixWidth,int radius,int index)</span><br><span class="line">{</span><br><span class="line">    int x=index%matrixWidth;</span><br><span class="line">    int offsetX=x-(radius+<span class="hljs-number">1</span>);</span><br><span class="line">    int y=index/matrixWidth;</span><br><span class="line">    int offsetY=radius-y;</span><br><span class="line">    <span class="hljs-keyword">return</span> (int2)(centerX+offsetX,centerY-offsetY);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> sampler_t sampler_img=CLK_NORMALIZED_COORDS_FALSE|CLK_ADDRESS_CLAMP_TO_EDGE;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//opencl kernel 代码</span></span><br><span class="line">kernel <span class="hljs-keyword">void</span> gaussian_blur(</span><br><span class="line">    read_only image2d_t src,</span><br><span class="line">    global write_only char* dst,</span><br><span class="line">    global read_only float* matrix,</span><br><span class="line">    read_only int radius,</span><br><span class="line">read_only int width)</span><br><span class="line">{</span><br><span class="line">    int x=get_global_id(<span class="hljs-number">0</span>);</span><br><span class="line">    int y=get_global_id(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">    float sumR,sumG,sumB,sumA;</span><br><span class="line">    int matrixWidth=radius*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;</span><br><span class="line">    int matrix_size=pow(matrixWidth,<span class="hljs-number">2</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;matrix_size;i++)</span><br><span class="line">    {</span><br><span class="line">        int2 pix=transform_pos(x,y,matrixWidth,radius,i);</span><br><span class="line">        uint4 rgba = read_imageui(src,sampler_img,pix);</span><br><span class="line">        sumR+=rgba.x*matrix[i];</span><br><span class="line">        sumG+=rgba.y*matrix[i];</span><br><span class="line">        sumB+=rgba.z*matrix[i];</span><br><span class="line">sumA+=rgba.w*matrix[i];</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">int loc=y*width*<span class="hljs-number">4</span>+x*<span class="hljs-number">4</span>;</span><br><span class="line">dst[loc]=sumR;</span><br><span class="line">dst[loc+<span class="hljs-number">1</span>]=sumG;</span><br><span class="line">dst[loc+<span class="hljs-number">2</span>]=sumB;</span><br><span class="line">dst[loc+<span class="hljs-number">3</span>]=sumA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Host代码：  </p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public <span class="hljs-keyword">void</span> Compute_cl(string imageFile)</span><br><span class="line">{</span><br><span class="line">    <span class="hljs-comment">//选取设备</span></span><br><span class="line">    <span class="hljs-keyword">var</span> platform = ComputePlatform.Platforms.FirstOrDefault();</span><br><span class="line">    <span class="hljs-keyword">var</span> device = platform.Devices.FirstOrDefault();</span><br><span class="line">    <span class="hljs-comment">//设置相关上下文</span></span><br><span class="line">    <span class="hljs-keyword">var</span> properties = <span class="hljs-keyword">new</span> ComputeContextPropertyList(platform);</span><br><span class="line">    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> ComputeContext(<span class="hljs-keyword">new</span>[] {device}, properties, <span class="hljs-literal">null</span>, IntPtr.Zero);</span><br><span class="line">    <span class="hljs-comment">//命令队列，用于控制执行的代码</span></span><br><span class="line">    ComputeCommandQueue commands = <span class="hljs-keyword">new</span> ComputeCommandQueue(context, context.Devices[<span class="hljs-number">0</span>],</span><br><span class="line">        ComputeCommandQueueFlags.None);</span><br><span class="line">    <span class="hljs-comment">//读取opencl代码</span></span><br><span class="line">    <span class="hljs-keyword">var</span> code = File.ReadAllText(@<span class="hljs-string">"gaussianblur.cl"</span>);</span><br><span class="line">    <span class="hljs-comment">//编译</span></span><br><span class="line">    <span class="hljs-keyword">var</span> program = <span class="hljs-keyword">new</span> ComputeProgram(context, code);</span><br><span class="line">    <span class="hljs-keyword">try</span></span><br><span class="line">    {</span><br><span class="line">        program.Build(<span class="hljs-keyword">new</span>[] {device}, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, IntPtr.Zero);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">catch</span> (Exception ex)</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-keyword">throw</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> images = CreateImageFromBitmap(imageFile, context,</span><br><span class="line">        ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//创建核心代码，就是cl代码中以kernel标识的函数</span></span><br><span class="line">    <span class="hljs-keyword">var</span> kernel = program.CreateKernel(<span class="hljs-string">"gaussian_blur"</span>);</span><br><span class="line">    <span class="hljs-comment">//矩阵规模</span></span><br><span class="line">    <span class="hljs-comment">//储存计算结果的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//创建的核心代码函数以这种方式来传参</span></span><br><span class="line">    <span class="hljs-keyword">var</span> resultBuffer=<span class="hljs-keyword">new</span> ComputeBuffer&lt;char&gt;(context,ComputeMemoryFlags.WriteOnly, dstBytes.Length);</span><br><span class="line">    kernel.SetMemoryArgument(<span class="hljs-number">0</span>, images);</span><br><span class="line">    kernel.SetMemoryArgument(<span class="hljs-number">1</span>, resultBuffer);</span><br><span class="line">    kernel.SetMemoryArgument(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> ComputeBuffer&lt;float&gt;(context,ComputeMemoryFlags.ReadOnly|ComputeMemoryFlags.CopyHostPointer,_matrix));</span><br><span class="line">    kernel.SetValueArgument(<span class="hljs-number">3</span>, Radius);</span><br><span class="line">    kernel.SetValueArgument(<span class="hljs-number">4</span>, (int)images.Width);</span><br><span class="line">    Console.WriteLine($<span class="hljs-string">"运行平台: {platform.Name}\n运行设备： {device.Name}\n"</span>);</span><br><span class="line">    Stopwatch sw = Stopwatch.StartNew();</span><br><span class="line">    <span class="hljs-keyword">var</span> climg = images;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//执行代码</span></span><br><span class="line">    commands.Execute(kernel, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> long[] {climg.Width, climg.Height}, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//read data</span></span><br><span class="line">    char[] resultArray = <span class="hljs-keyword">new</span> char[dstBytes.Length];</span><br><span class="line">    <span class="hljs-keyword">var</span> arrHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned);</span><br><span class="line">    commands.Read(resultBuffer, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>, dstBytes.Length, arrHandle.AddrOfPinnedObject(), <span class="hljs-literal">null</span>);</span><br><span class="line">    <span class="hljs-comment">//commands.ReadFromImage(images.Item2, processeddata.Scan0, true, null);</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> resultHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned);</span><br><span class="line">    <span class="hljs-keyword">var</span> bmp=<span class="hljs-keyword">new</span> Bitmap(climg.Width,climg.Height, climg.Width*<span class="hljs-number">4</span>, PixelFormat.Format32bppArgb, resultHandle.AddrOfPinnedObject());</span><br><span class="line">    <span class="hljs-keyword">var</span> elapsed = sw.Elapsed;</span><br><span class="line">    Console.WriteLine($<span class="hljs-string">"耗时: {elapsed.TotalMilliseconds} ms\n"</span>);</span><br><span class="line">    kernel.Dispose();</span><br><span class="line"></span><br><span class="line">    bmp.Save(<span class="hljs-string">"processed_cl.bmp"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相同尺寸的图片处理，使用 Intel Core i7-4770 自带的核显 HD4600 处理，耗时只需要164毫秒。</p><p>以下是相关测试结果： </p><p></p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">运行平台: Intel(R) OpenCL</span><br><span class="line">运行设备： Intel(R) HD Graphics 4600</span><br><span class="line">处理图片尺寸：790*501</span><br><span class="line">OpenCL处理耗时: 13.6597 ms</span><br><span class="line"></span><br><span class="line">处理图片尺寸：790*501</span><br><span class="line">常规方法耗时: 11482.9402 ms</span><br><span class="line"></span><br><span class="line">运行平台: Intel(R) OpenCL</span><br><span class="line">运行设备： Intel(R) HD Graphics 4600</span><br><span class="line">处理图片尺寸：1339*693</span><br><span class="line">OpenCL处理耗时: 33.0095 ms</span><br><span class="line"></span><br><span class="line">处理图片尺寸：1339*693</span><br><span class="line">常规方法耗时: 26908.9926 ms</span><br><span class="line"></span><br><span class="line">运行平台: Intel(R) OpenCL</span><br><span class="line">运行设备： Intel(R) HD Graphics 4600</span><br><span class="line">处理图片尺寸：1920*1080</span><br><span class="line">OpenCL处理耗时: 51.3885 ms</span><br><span class="line"></span><br><span class="line">处理图片尺寸：1920*1080</span><br><span class="line">常规方法耗时: 60147.3815 ms</span><br></pre></td></tr></tbody></table></figure><br>当然，常规方法都只使用了单线程，还未发挥多核CPU的威力，然而，可以预见的是，即使是使用多线程，提升也是有限的。<p></p><p>原图：<br><img src="/2018/01/02/gaussian_blur_opencl/screen_shot_gaus.png" class=""><br>高斯模糊：<br><img src="/2018/01/02/gaussian_blur_opencl/processed_cl.bmp" class=""></p><p>代码： <a href="https://github.com/gandalfliang/cloo_netstandard/tree/temp" target="_blank" rel="noopener">https://github.com/gandalfliang/cloo_netstandard/tree/temp</a> </p><font size="4" color="red">Update: 在nVidia的环境下会导致处理后的图片出现花屏现象，估计是cl代码的问题，又或者是nVidia的驱动有问题？下次再更新</font></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;高斯模糊（ &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A&lt;/a&gt; ）是一种常见的图像处理算法，使用高斯分布与图像做卷积，得到模糊的效果。其二维定义：&lt;br&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/c36071d89adc2f4da470b45ce05c33ca93744577&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;σ是正态分布的标准偏差。在应用的时候，假设σ为2.5。对于模糊半径为1，则高斯矩阵为3*3的一个矩阵，以[1,1]为中心，带入公式计算高斯矩阵的值，得到：&lt;br&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="OpenCL" scheme="https://gandalfliang.github.io/tags/OpenCL/"/>
    
      <category term="高性能计算" scheme="https://gandalfliang.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="图像处理" scheme="https://gandalfliang.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="高斯模糊" scheme="https://gandalfliang.github.io/tags/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/"/>
    
  </entry>
  
  <entry>
    <title>.NET Standard CLOO</title>
    <link href="https://gandalfliang.github.io/2017/12/25/cloo_net_standard/"/>
    <id>https://gandalfliang.github.io/2017/12/25/cloo_net_standard/</id>
    <published>2017-12-25T03:01:38.000Z</published>
    <updated>2018-02-12T07:23:20.297Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于 .NET Standard 2.0 已经支持大量的.NET api，移植CLOO已经是毫无难度的一件事情 <a href="https://github.com/gandalfliang/cloo_netstandard" target="_blank" rel="noopener">Github</a></p><p>CLOO使用p/invoke方式调用opencl api，但是对于不同平台下，opencl 的名称并不一致，例如在linux下为libOpenCL.so，Windows下为OpenCL.dll，且 .NET Standard 没有提供 Mono 类似的 dllmap 模式，因此，现在来说还不能达到用一个package，在所有平台引用的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;鉴于 .NET Standard 2.0 已经支持大量的.NET api，移植CLOO已经是毫无难度的一件事情 &lt;a href=&quot;https://github.com/gandalfliang/cloo_netstandard&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="NET Standard" scheme="https://gandalfliang.github.io/tags/NET-Standard/"/>
    
      <category term="CLOO" scheme="https://gandalfliang.github.io/tags/CLOO/"/>
    
  </entry>
  
  <entry>
    <title>Gitsoler</title>
    <link href="https://gandalfliang.github.io/2017/12/16/Gitsoler/"/>
    <id>https://gandalfliang.github.io/2017/12/16/Gitsoler/</id>
    <published>2017-12-16T03:01:38.000Z</published>
    <updated>2018-02-12T07:23:44.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gitsoler-a-Visual-Studio-extension-now-goes-public-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler"><a href="#Gitsoler-a-Visual-Studio-extension-now-goes-public-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler" class="headerlink" title="Gitsoler - a Visual Studio extension, now goes public: https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler"></a>Gitsoler - a Visual Studio extension, now goes public: <a href="https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gitsoler-a-Visual-Studio-extension-now-goes-public-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="工具" scheme="https://gandalfliang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Visual Studio" scheme="https://gandalfliang.github.io/tags/Visual-Studio/"/>
    
      <category term="Extension" scheme="https://gandalfliang.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>“阻断疗法” - 拯救 WPF 启动过程中发生设备热插拔导致触摸失效问题</title>
    <link href="https://gandalfliang.github.io/2017/12/02/WPFLostTouchCapability/"/>
    <id>https://gandalfliang.github.io/2017/12/02/WPFLostTouchCapability/</id>
    <published>2017-12-02T05:58:27.000Z</published>
    <updated>2021-02-10T03:52:13.647Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>如果你在WPF程序启动过程中进行设备热插拔（例如，插入一个U盘，一个USB摄像头），那么你的WPF程序很有可能失去所有触摸消息响应，通过 Tablet.TabletDevices.Count 检查当前程序的挂靠触摸设备，发现为0。有趣的是，如果你将触摸线重新插拔后，程序恢复正常。所以，这是WPF的Bug，微软的锅。那么这个锅的根本原因是啥？有兴趣的可以调试 .net framework 源码，这里没有深究。<br><a id="more"></a><br>如上面讲到，触摸线重新插拔就可以解决这个问题，但是，导致这个问题的热插拔设备也不是触摸设备啊，只是一个普通的U盘，反过来想，如果导致问题的不是触摸设备热插拔，反而触摸设备的热插拔能够修复这个问题，那我能不能“模拟”一下触摸设备的热插拔事件呢？在这篇<a href="https://msdn.microsoft.com/en-us/library/dd901337%28v=vs.90%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">文章</a>里描述怎样模拟触摸设备移除事件来达到禁用WPF触摸的效果,反过来试试，通过 OnTabletAdded 事件看看能不能发生奇迹。然而，奇迹并没有发生，所以这个方法不行。<br>既然模拟设备添加事件的方法不行，那我从源头阻挡这个问题的发生：启动过程中不要处理设备变动事件。那么问题来了，我想要阻断 win32 WM 事件通知，必须要拿到一个窗口句柄呀，但是在 mainwindow show 出来的时候，这个问题已经发生了，这个时候的阻断已经没有效果了，一定要程序启动一开始做阻断。进一步搜索，这里<a href="https://stackoverflow.com/questions/38642479/how-to-disable-wpf-tablet-support-in-surface-4-pro" target="_blank" rel="noopener">https://stackoverflow.com/questions/38642479/how-to-disable-wpf-tablet-support-in-surface-4-pro</a> 是一个突破口：  </p><blockquote><p>WPF does not register to these messages on the applications MainWindow, but through a hidden windows named “SystemResources…” which is created for each application instance. So handling those messages on the MainWindow (which would be easy) does not help here.</p></blockquote><p>相信看到这里，聪明的你已经知道怎么做了。  </p><p></p><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WPFTouchUtil</span></span></span><br><span class="line"><span class="hljs-class">    </span>{</span><br><span class="line">        <span class="hljs-comment">//添加钩子，阻断设备改动消息</span></span><br><span class="line">        public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> HandleDeviceChangedWM()</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-comment">// hook into internal class SystemResources to keep it from updating the TabletDevices on system events</span></span><br><span class="line">            object hwndWrapper = GetSystemResourcesHwnd();</span><br><span class="line">            <span class="hljs-keyword">if</span> (hwndWrapper != <span class="hljs-literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="hljs-comment">// invoke hwndWrapper.AddHook( .. our method ..)</span></span><br><span class="line">                <span class="hljs-keyword">var</span> internalHwndWrapperType = hwndWrapper.GetType();</span><br><span class="line">                <span class="hljs-comment">// if the delegate is already set, we have already added the hook.</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (_handleAndHideMessageDelegate == <span class="hljs-literal">null</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="hljs-comment">// create the internal delegate that will hook into the window messages</span></span><br><span class="line">                    <span class="hljs-comment">// need to hold a reference to that one, because internally the delegate is stored through a WeakReference object</span></span><br><span class="line">                    <span class="hljs-keyword">var</span> internalHwndWrapperHookDelegate = internalHwndWrapperType.Assembly.GetType(<span class="hljs-string">"MS.Win32.HwndWrapperHook"</span>);</span><br><span class="line">                    <span class="hljs-keyword">var</span> handleAndHideMessagesHandle = <span class="hljs-keyword">typeof</span>(WPFTouchUtil).GetMethod(nameof(HandleAndHideMessages), BindingFlags.Static | BindingFlags.NonPublic);</span><br><span class="line">                    _handleAndHideMessageDelegate = Delegate.CreateDelegate(internalHwndWrapperHookDelegate, handleAndHideMessagesHandle);</span><br><span class="line">                    <span class="hljs-comment">// add a delegate that handles WM_TABLET_ADD</span></span><br><span class="line">                    internalHwndWrapperType.InvokeMember(<span class="hljs-string">"AddHook"</span>,</span><br><span class="line">                        BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.Public,</span><br><span class="line">                        <span class="hljs-literal">null</span>, hwndWrapper, <span class="hljs-keyword">new</span> object[] { _handleAndHideMessageDelegate });</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//移除钩子，恢复状态</span></span><br><span class="line">        public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> RestoreDeviceChangedWM()</span><br><span class="line">        {</span><br><span class="line">            object hwndWrapper = GetSystemResourcesHwnd();</span><br><span class="line">            <span class="hljs-keyword">if</span> (hwndWrapper != <span class="hljs-literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="hljs-keyword">var</span> internalHwndWrapperType = hwndWrapper.GetType();</span><br><span class="line"></span><br><span class="line">                internalHwndWrapperType.InvokeMember(<span class="hljs-string">"RemoveHook"</span>,</span><br><span class="line">                    BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.Public,</span><br><span class="line">                    <span class="hljs-literal">null</span>, hwndWrapper, <span class="hljs-keyword">new</span> object[] {_handleAndHideMessageDelegate});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        private <span class="hljs-keyword">static</span> Delegate _handleAndHideMessageDelegate = <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line">        private <span class="hljs-keyword">static</span> object GetSystemResourcesHwnd()</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-keyword">var</span> internalSystemResourcesType = <span class="hljs-keyword">typeof</span>(Application).Assembly.GetType(<span class="hljs-string">"System.Windows.SystemResources"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// get HwndWrapper from internal property SystemRessources.Hwnd;</span></span><br><span class="line">            <span class="hljs-keyword">var</span> hwndWrapper = internalSystemResourcesType.InvokeMember(<span class="hljs-string">"Hwnd"</span>,</span><br><span class="line">                        BindingFlags.GetProperty | BindingFlags.Static | BindingFlags.NonPublic,</span><br><span class="line">                        <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> hwndWrapper;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        private <span class="hljs-keyword">static</span> IntPtr HandleAndHideMessages(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)</span><br><span class="line">        {</span><br><span class="line">            <span class="hljs-keyword">if</span> (msg == (int)WindowMessage.WM_DEVICECHANGE)</span><br><span class="line">            {</span><br><span class="line">                handled = <span class="hljs-literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">return</span> IntPtr.Zero;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        enum WindowMessage : int</span><br><span class="line">        {</span><br><span class="line">            WM_DEVICECHANGE = <span class="hljs-number">0x0219</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><br>在程序刚启动的时候添加“阻断”，启动流程过后，不要忘了恢复状态。<br>缺陷，如果程序启动过程中，真的发生了触摸设备变动，也会被阻断。<p></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;如果你在WPF程序启动过程中进行设备热插拔（例如，插入一个U盘，一个USB摄像头），那么你的WPF程序很有可能失去所有触摸消息响应，通过 Tablet.TabletDevices.Count 检查当前程序的挂靠触摸设备，发现为0。有趣的是，如果你将触摸线重新插拔后，程序恢复正常。所以，这是WPF的Bug，微软的锅。那么这个锅的根本原因是啥？有兴趣的可以调试 .net framework 源码，这里没有深究。&lt;br&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="BUG" scheme="https://gandalfliang.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>Timelapse#2</title>
    <link href="https://gandalfliang.github.io/2017/10/20/Timelapse2/"/>
    <id>https://gandalfliang.github.io/2017/10/20/Timelapse2/</id>
    <published>2017-10-20T12:33:39.000Z</published>
    <updated>2019-01-23T10:56:34.338Z</updated>
    
    <content type="html"><![CDATA[<p>Lens: Nikkor 24-mm F2.8<br>f2.8  70mm  ISO400  </p><video src="./gz_timelapse_cold_signature.mp4" type="video/mp4" controls></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lens: Nikkor 24-mm F2.8&lt;br&gt;f2.8  70mm  ISO400  &lt;/p&gt;
&lt;video src=&quot;./gz_timelapse_cold_signature.mp4&quot; type=&quot;video/mp4&quot; controls&gt;&lt;/video&gt;


      
    
    </summary>
    
      <category term="摄影" scheme="https://gandalfliang.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="Timelapse" scheme="https://gandalfliang.github.io/tags/Timelapse/"/>
    
      <category term="Nikon" scheme="https://gandalfliang.github.io/tags/Nikon/"/>
    
      <category term="Guangzhou" scheme="https://gandalfliang.github.io/tags/Guangzhou/"/>
    
      <category term="单反" scheme="https://gandalfliang.github.io/tags/%E5%8D%95%E5%8F%8D/"/>
    
      <category term="Video" scheme="https://gandalfliang.github.io/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>WPF 渲染小结</title>
    <link href="https://gandalfliang.github.io/2017/09/20/WPF_rendering_perf/"/>
    <id>https://gandalfliang.github.io/2017/09/20/WPF_rendering_perf/</id>
    <published>2017-09-20T04:19:30.000Z</published>
    <updated>2021-02-10T03:52:13.653Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>在上一篇文章<a href="https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/">D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践</a>最后，提到DropShadowEffect严重影响到D3DImage的渲染性能问题，导致程序在渲染8分屏（8个远端视频）的时候，出现严重的性能下降，渲染卡顿。要知道，在使用原生窗口渲染方案渲染8分屏，CPU占用和内存占用也不过25%和~200Mb，稍差一点，使用D3DImage优化后方案渲染，CPU占用并没有出现多大的跳跃，大约在30%左右。即使是添加了DropShadowEffect的情况下，CPU占用和内存占用好像都没有多大变化；既然在CPU和内存占用都没有多大变化的情况下，WPF渲染卡顿，那肯定（可能吧）是“帧生成”时间过长的锅。<br><a id="more"></a></p><h2 id="帧生成时间"><a href="#帧生成时间" class="headerlink" title="帧生成时间"></a>帧生成时间</h2><p>玩游戏的人都知道，影响游戏帧数的一个关键因素是帧生成时间，帧生成时间过长必定导致游戏FPS下降，游戏不流畅。帧生成时间并不等同帧更新时间，这个需要搞清楚。例如一个游戏锁帧60FPS,那么帧更新时间为1000/60=16.6ms,通常来说，如果你硬件性能足够强劲，那么帧生成时间要小于16.6ms才能保证游戏运行在60FPS的帧率下，否则会掉帧。类似的，WPF的渲染帧率下降可能（无责任猜想）也是同样的因素导致。But why?  </p><h2 id="DropShadowEffect-的锅"><a href="#DropShadowEffect-的锅" class="headerlink" title="DropShadowEffect 的锅"></a>DropShadowEffect 的锅</h2><p>不要误会，DropShadowEffect并没有什么过错。只是在特定情境下，DropShadowEffect（及其他所有Effect类），就是WPF渲染瓶颈的关键： </p><ul><li>将Effect应用到时刻变化的元素</li><li>在应用了Effect的元素上，叠加了其他时刻变化的兄弟元素</li><li>… </li></ul><p>远程会议的问题就是碰到了第二种情景，我们以为只要不直接应用DropShadowEffect到D3DImage这种时刻更新帧的元素上，应该就能避免渲染瓶颈，然而被打脸。<br>说了这么久，好像还是没有说为什么；年轻人，不要这么着急，继续往下看。  </p><h2 id="WPF-的渲染知识两则"><a href="#WPF-的渲染知识两则" class="headerlink" title="WPF 的渲染知识两则"></a>WPF 的渲染知识两则</h2><ul><li>当WPF在渲染一个窗口的时候，它只更新需要更新的区域，称为脏区（DirtyRect）。</li><li>显存的占用与渲染面积成正相关</li></ul><p>使用下面这个例子来模拟导致问题的场景：<br><br>左边是应用了DropShadowEffect的Grid,中间是应用ColorAnimation的Grid,右边是3个视频渲染。暂时来说，情况看起来还是可以的，没有出现明显的渲染卡顿，整个界面的渲染都维持在一个比较高的帧数。<br><img src="/2017/09/20/WPF_rendering_perf/origin_gif.gif" class=""><br>那么，将中间的元素叠加在左边的元素上看看：<br><img src="/2017/09/20/WPF_rendering_perf/overlay_lag.gif" class=""><br>问题出现了，帧率下降严重,视频出现卡顿，ColorAnimation变得不平滑：<br><img src="/2017/09/20/WPF_rendering_perf/overlay_gif.gif" class=""><br>在这两种情况下，脏区数量都是一样的，分别是始终变化的ColorAnimation Grid和视频区，唯一不同的是，ColorAnimation Grid的位置变了，与应用了DropShadowEffect的Grid部分重叠了，这导致每帧渲染多了一个HW IRT(hardware intermediate render target)，对于WPF来说，HW IRT是一个代价高昂的渲染过程，比它更惨的是SW IRT,如果你的WPF程序在渲染过程中出现多个这种渲染过程，那么可以肯定你的程序需要完成大量的工作来渲染你的程序。</p><h2 id="那么，什么是IRT"><a href="#那么，什么是IRT" class="headerlink" title="那么，什么是IRT?"></a>那么，什么是IRT?</h2><p>Intermediate Render Target。在现代的图形处理单元(GPU)中，我们可以将我们要进行渲染的内容先在Render Target中渲染，然后像素着色器可以通过处理这个Render Target来添加特定的效果，这个过程完成后才将处理完的数据储存到后台缓存（Back Buffer)，这个时候渲染线程（Render Thread)可以将back buffer拷贝到前台缓存（Front Buffer)进行显示。对应到上面的例子，动态元素在拥有DropShadowEffect的元素上刷新，引起脏区更新，这个脏区有关DropShadwoEffect，DropShadowEffect需要像素着色器渲染指令（因为它本身就是由HLSL创建的），嘣！！！，IRT就来了。但是，IRT在一次渲染中是很正常的啊，有些WPF程序在一次渲染中可能存在几个IRT都不会引起这么明显的性能下降。4K是性能的试金石，要知道，我们的程序是运行在4K下的，变化的脏区面积足够大，才引起了显著的性能下降，而且，不要忘了，WPF在使用像素着色器时有天生的缺陷，这篇<a href="https://jeremiahmorrill.wordpress.com/2011/02/14/a-critical-deep-dive-into-the-wpf-rendering-system/" target="_blank" rel="noopener">文章</a>有详细说明,其中提到的关键一点： </p><blockquote><p>WPF has an extensible pixel shader API, along with some build in effects.  This allows developers to really add some very unique effects to their UI.  In Direct3D when you apply a shader to an existing texture, it’s very typical to use an intermediate rendertarget…after all you can’t sample from a texture you are writing to!  WPF does this also, but unfortunately it will create a totally new texture EACH FRAME and destroy it when it’s done.  Creating and destroying GPU resources is one of the slowest things you can do on a per frame basis.  I wouldn’t even typically do this with system memory allocations of that size. There would be a considerable performance increase on the use of shaders if somehow these intermediate surfaces can be reused.  If you’ve ever wondered why you get noticeable CPU usage with these hardware accelerated shaders, this is why.  </p></blockquote><p>至此，WPF的渲染相关文章结束。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在上一篇文章&lt;a href=&quot;https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/&quot;&gt;D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践&lt;/a&gt;最后，提到DropShadowEffect严重影响到D3DImage的渲染性能问题，导致程序在渲染8分屏（8个远端视频）的时候，出现严重的性能下降，渲染卡顿。要知道，在使用原生窗口渲染方案渲染8分屏，CPU占用和内存占用也不过25%和~200Mb，稍差一点，使用D3DImage优化后方案渲染，CPU占用并没有出现多大的跳跃，大约在30%左右。即使是添加了DropShadowEffect的情况下，CPU占用和内存占用好像都没有多大变化；既然在CPU和内存占用都没有多大变化的情况下，WPF渲染卡顿，那肯定（可能吧）是“帧生成”时间过长的锅。&lt;br&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="DirectX" scheme="https://gandalfliang.github.io/tags/DirectX/"/>
    
      <category term="渲染" scheme="https://gandalfliang.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="Profiling" scheme="https://gandalfliang.github.io/tags/Profiling/"/>
    
      <category term="Perforator" scheme="https://gandalfliang.github.io/tags/Perforator/"/>
    
  </entry>
  
  <entry>
    <title>D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践</title>
    <link href="https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/"/>
    <id>https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/</id>
    <published>2017-09-11T04:19:30.000Z</published>
    <updated>2019-01-10T12:18:47.821Z</updated>
    
    <content type="html"><![CDATA[<p>D3dImage，.Net Framework 3.5 之后，微软提供的一个全新的ImageSource<a href="https://msdn.microsoft.com/en-us/library/system.windows.interop.d3dimage.aspx" target="_blank" rel="noopener">对象</a>，可以在WPF中很好的呈现DirectX内容；在此之前，你只能将DirectX内容直接渲染在Windows窗口之上，这必然引起令人头疼的AirSpace问题，为了在这些内容上面添加我们习以为常的WPF UI 元素，你只能使用Popup来承载这些内容，完全丧失WPF UI开发的灵活性，且有经验的WPF程序员都知道一个事实：WPF Popup就是一个深坑 - 你需要手动处理各种显示隐藏问题、因为其导致的焦点问题，显示层级问题以及最令人头疼的性能问题，特别是在4K屏幕下，因为我们都知道，Popup就是一个Window，为了解决Airspace问题而使用Popup来承载UI必定需要使其AllowTransparency=True，这就引起了另外一个问题，透明窗口占用内存与其面积成正相关，在4K屏幕下，你可能将整个程序大部分的内存占用贡献给了这些Popup UI。说了这么多，好像在诉控Popup有多么的垃圾（它的确如此，如果在做大量的UI容器时）。 </p><p>年轻人，如果你觉得Airspace问题真的没有办法解决了，只能用Popup这种技术手段来规避了，那么听老人一句话，不要浪费时间在Popup上了，因为你在前期投入的时间来规避种种Popup UI导致的问题以及各种你意想不到的Bug，到最后总会碰到解决不了，完全不能规避的情况，从而导致整个Popup UI替换方案完全失败的情形。<br><a id="more"></a></p><h2 id="什么是AirSpace问题"><a href="#什么是AirSpace问题" class="headerlink" title="什么是AirSpace问题"></a>什么是AirSpace问题</h2><p>这是一个很复杂的问题，涉及到整个WPF的<a href="https://blogs.msdn.microsoft.com/dwayneneed/2013/02/26/mitigating-airspace-issues-in-wpf-applications/" target="_blank" rel="noopener">渲染机制</a>，简单的来说，就是对于WPF窗口的子窗口，其并不是由父窗口负责渲染的，而是由其自己负责自己的渲染，子窗口不能像其他元素一样由父元素来进行布局、渲染（这很好理解），因此，如果我们要在一个WPF窗口中承载另外一个子窗口，那么其渲染并不受父窗口控制，它会渲染在父窗口所有元素之上，这就是导致上面提到的需要用Popup UI来规避Airspace问题的原因。那么问题来了，我为什么要在一个窗口里面渲染另外一个窗口？这不科学。这的确是一个不科学的操作，因为没人会这样做，除非你需要和DirectX内容打交道，特别是对于在WPF做多媒体应用开发的程序员，WPF和DirectX内容的交互 是一个不可避免的问题（虽然我觉得用WPF做多媒体应用本身就存在问题，但这不在本篇文章讨论的范围）。不仅是DirectX内容，在WPF中承载WinForm控件也有同样的问题，为了解决这种问题，微软曾在.Net Framework 4.5的某个预览版（如果没记错的话）中提供了对应的解决方案，但是在正式版中并没有保留，很可惜。</p><h2 id="WPF多媒体程序开发的好帮手-D3DImage"><a href="#WPF多媒体程序开发的好帮手-D3DImage" class="headerlink" title="WPF多媒体程序开发的好帮手 - D3DImage"></a>WPF多媒体程序开发的好帮手 - D3DImage</h2><p>D3DImage就是一个全新的ImageSource，你可以完全根据你对ImageSource的理解来使用它<a href="https://gandalfliang.github.io/2017/06/11/D3DImageInWPF/">D3DImage</a>。为什么说它是WPF多媒体程序的好帮手？正如我上面提到的，我不觉得WPF是多媒体应用开发的第一选择，多媒体应用是一种性能敏感的程序类型，先不说使用WPF你很难触碰到底层的渲染机制，进行调优；而且，你不能原生访问Direct3D接口，即使，至少对于Windows平台下，多媒体内容大多都使用Direct3D API来进行渲染、绘制（更不用说OpenGL了，其对于WPF来说几乎就是一个不可能的选项）。因此我们需要D3DImage，其为你在WPF中使用Direct3D接口和内容提供了一种可能，尽管那是一种不那么直观的方式。<br>说到底，我们需要解决的问题是将Direct3D原生渲染的内容，以一种WPF熟悉的，原生的方式渲染在WPF上。在D3DImage之前，你只能直接渲染在窗口上，因为窗口是Direct3D渲染设备的必须参数。而D3DImage，不要误会，它并不是可以让Direct3D不用窗口进行渲染，而是为Direct3D渲染的内容提供了一个“通道”，这个”通道”使WPF可以将ID3DDevice上的渲染表面ID3DSurface更新到其渲染线程中（这种说法并不准确，但是你可以先这样理解，至于它们是怎样”共享“表面的，我们以后再谈）。</p><h2 id="一切看起来都是那么完美，但是…"><a href="#一切看起来都是那么完美，但是…" class="headerlink" title="一切看起来都是那么完美，但是…"></a>一切看起来都是那么完美，但是…</h2><p>可以想象的到，D3DImage方式并不能提供比肩原生渲染的性能，不论是CPU占用还是内存占用。特别是当你需要兼顾Windows XP的时候，那性能就更加难看了。WPF虽然说是支持硬件加速的一个框架，但是它有<a href="https://gandalfliang.github.io/2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/">原生缺陷</a>，这篇文章描述了一些深入的问题。要知道，在Windows Vista之前，即Windows Xp，只能使用D3D9接口创建D3dDevice，我们甚至不能使用D3D9Ex接口，对于D3DImage来说，这是一个很大的性能损耗，因为由D3D9接口创建的D3dSurface与WPF的D3Dimage渲染过程中存在一个很恶心的过程，WPF需要将显存中的D3DSurface内容拷贝回系统内存，处理完后再拷贝回显存进行渲染，毫无疑问会导致CPU占用和内存占用上升。我们使用剪辑师来做一个实验，在关闭硬件加速的情况下，对比使用两种接口来创建渲染表面的性能表现：<br>在关闭硬件加速的情况下，使用剪辑师播放一个2K分辨率的视频在不同时刻的CPU占用：<br><img src="/2017/09/11/D3DImageInDepth/image2017-9-11_17-34-12.png" class=""></p><p>可以看出存在明显的性能差别，在使用D3DEx接口创建渲染表面进行和WPF的交互操作时，并不存在上面提到的显存→系统内存拷贝问题，其直接在显存中进行拷贝，这样会降低CPU损耗。即使这样，它也不能提供比原生窗口渲染更好的性能，这在我们意料之内。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>不要支持Windows XP</li><li>使用D3D9Ex以上接口来创建你要在D3DImage承载的Direct3D内容</li><li>不要在UI上使用DropShadowEffect，一点都不可以<br>关于这一点，又是一个可以深究的问题，但是这里就先简单的说一下。在远程会议的开发中，我们在渲染8分屏的时候，发现使用D3DImage进行视频渲染的时候，性能表现远远低于原生窗口渲染的方式，虽然知道D3DImage性能上与原生渲染存在差距，但是也不可能相差这么远。刚开始的时候我并没有怀疑DropShadowEffect，因为我知道它会带来性能问题，因此我还故意将其应用到一个空的Grid上，而不是直接应用到D3DImage上，而且这个Grid和Image并不是父子关系，在我的印象中，这样可以规避将整个D3DImage的像素数据进行DropShadowEffect的管道数据处理（DropShadowEffect本质是一个像素着色器，像素着色器是一个高性能组件，对于现代3D游戏来说，是一个必不可少的组件，但是<a href="https://gandalfliang.github.io/2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/">这篇文章</a>已经提到，WPF里的像素着色器并不完全是那么一回事），按理说，性能瓶颈并不应该出现在这里，然而，它的确是这里，原因是啥？我也不清楚，或许以后有结论之后我们再开一篇文章来谈谈。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;D3dImage，.Net Framework 3.5 之后，微软提供的一个全新的ImageSource&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.windows.interop.d3dimage.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对象&lt;/a&gt;，可以在WPF中很好的呈现DirectX内容；在此之前，你只能将DirectX内容直接渲染在Windows窗口之上，这必然引起令人头疼的AirSpace问题，为了在这些内容上面添加我们习以为常的WPF UI 元素，你只能使用Popup来承载这些内容，完全丧失WPF UI开发的灵活性，且有经验的WPF程序员都知道一个事实：WPF Popup就是一个深坑 - 你需要手动处理各种显示隐藏问题、因为其导致的焦点问题，显示层级问题以及最令人头疼的性能问题，特别是在4K屏幕下，因为我们都知道，Popup就是一个Window，为了解决Airspace问题而使用Popup来承载UI必定需要使其AllowTransparency=True，这就引起了另外一个问题，透明窗口占用内存与其面积成正相关，在4K屏幕下，你可能将整个程序大部分的内存占用贡献给了这些Popup UI。说了这么多，好像在诉控Popup有多么的垃圾（它的确如此，如果在做大量的UI容器时）。 &lt;/p&gt;
&lt;p&gt;年轻人，如果你觉得Airspace问题真的没有办法解决了，只能用Popup这种技术手段来规避了，那么听老人一句话，不要浪费时间在Popup上了，因为你在前期投入的时间来规避种种Popup UI导致的问题以及各种你意想不到的Bug，到最后总会碰到解决不了，完全不能规避的情况，从而导致整个Popup UI替换方案完全失败的情形。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="D3DImage" scheme="https://gandalfliang.github.io/tags/D3DImage/"/>
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="DirectX" scheme="https://gandalfliang.github.io/tags/DirectX/"/>
    
  </entry>
  
</feed>
