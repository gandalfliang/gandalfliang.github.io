{"meta":{"title":"gandalfliang的个人博客","subtitle":null,"description":null,"author":"gandalfliang","url":"https://gandalfliang.github.io"},"pages":[{"title":"categories","date":"2017-03-06T11:54:06.317Z","updated":"2017-03-06T11:54:06.000Z","comments":true,"path":"categories/index.html","permalink":"https://gandalfliang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-06T11:50:17.634Z","updated":"2017-03-06T11:50:17.634Z","comments":true,"path":"tags/index.html","permalink":"https://gandalfliang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JIT Loop Invariant Hoisting","slug":"jit-loop-invariant-hoisting","date":"2019-01-17T11:06:38.000Z","updated":"2019-01-17T11:18:04.577Z","comments":true,"path":"2019/01/17/jit-loop-invariant-hoisting/","link":"","permalink":"https://gandalfliang.github.io/2019/01/17/jit-loop-invariant-hoisting/","excerpt":"","text":"在上一篇文章中，我们已经对 Loop Invariant 概念有一个简单的了解，在文章的最后提到的 Loop Invariant 将在这篇文章做一个简单的介绍。 在我们开始之前如果你了解 C# 程序的运行，应该知道 C# 代码先被编译器编译为 MSIL 中间代码，在实际运行的时候才通过 JIT 编译器将 MSIL 代码编译成机器代码并运行。因此，编译器有两个时段可以对代码进行优化： C# -&gt; MSIL MSIL -&gt; MACHINE CODE 但是，C#到MSIL的优化有限，大部分优化都是通过 JIT 来完成的。而这篇文章也是围绕微软最新的 RyuJIT 编译器来展开，其可能与旧的 JIT有所区别，但是应该差异不大。 Loop Invariant首先看一下微软对 Loop Invariant Code Hoisting 的说明： This phase traverses all the loop nests, in outer-to-inner order (thus hoisting expressions outside the largest loop in which they are invariant). It traverses all of the statements in the blocks in the loop that are always executed. If the statement is: A valid CSE candidate Has no side-effects Does not raise an exception OR occurs in the loop prior to any side-effects Has a valid value number, and it is a lclVar defined outside the loop, or its children (the value numbers from which it was computed) are invariant. JIT 从外到内遍历所有的循环嵌套。它遍历循环嵌套结构中始终会被运行的BasicBlock（这是JIT里的类型，这里暂不展开，你可以暂时将其理解为编译器的基本类型）里的语句，并且这些语句符合以下条件： 是一个 CSE 没有副作用 不会触发异常或者发生在任何副作用之前 拥有一个可用的数字，这个数字定义在循环嵌套外或者其子元素是不可变的 上面提到的始终会被运行的循环嵌套（loop that are always executed), 如何理解? 嗯…，简单来讲，我们知道的循环结构，例如大部分编程语言都会有的 for loop 和 do while loop，这两种循环嵌套中，do while loop 就符合一定会被执行的循环嵌套，因为循环判断在一次循环后才会执行，而有些for loop 也可以被转换为 do while loop, JIT 会判断这个loop能否转换为do while loop后才进行后续的 loop hoisting 操作。 CSE - Common Subexpression Elimination Utilizes value numbers to identify redundant computations, which are then evaluated to a new temp lvlVar, and then reused. 利用数字来识别（替代？）多余的计算，然后将它们计算为新的临时值，并重复利用。就如上篇文章中for循环中的 x+y。观察RyuJIT 中用于判定CSE的函数片段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/***************************************************************************** * * The following determines whether the given expression is a worthy CSE * candidate. */bool Compiler::optIsCSEcandidate(GenTreePtr tree)&#123; /* No good if the expression contains side effects or if it was marked as DONT CSE */ if (tree-&gt;gtFlags &amp; (GTF_ASG|GTF_DONT_CSE)) &#123; return false; &#125; /* The only reason a TYP_STRUCT tree might occur is as an argument to GT_ADDR. It will never be actually materialized. So ignore them. Also TYP_VOIDs */ var_types type = tree-&gt;TypeGet(); genTreeOps oper = tree-&gt;OperGet(); if (type == TYP_STRUCT || type == TYP_VOID) return false; ...#ifdef _TARGET_X86_ if (type == TYP_FLOAT) &#123; // TODO-X86-CQ: Revisit this // Don't CSE a TYP_FLOAT on x86 as we currently can only enregister doubles return false; &#125;#else if (oper == GT_CNS_DBL) &#123; // TODO-CQ: Revisit this // Don't try to CSE a GT_CNS_DBL as they can represent both float and doubles return false; &#125;#endif ... /* Check for some special cases */ switch (oper) &#123; ... case GT_LCL_VAR: return false; // Can't CSE a volatile LCL_VAR ... &#125; ...&#125; 当然，这个函数还有许多细节，这里只挑选几个典型的片段。看代码可以知道： 可以明确指定不能使用CSE 不能有赋值表达式 x86下 float 不能作为CSE, x64下不支持 float 和 double 不支持struct和void 如果是可变(volatile)的变量，也不能作为CSE，这在之前的一篇文章中有对 volatile 的说明 Loop-Hoisting 还有颇多细节这里并没有覆盖，有兴趣可以去看源码：https://github.com/dotnet/coreclr/blob/release/1.0.0-rc1/src/jit/optimizer.cpp","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://gandalfliang.github.io/tags/C/"},{"name":"编译器优化","slug":"编译器优化","permalink":"https://gandalfliang.github.io/tags/编译器优化/"},{"name":"Loop Hoisting","slug":"Loop-Hoisting","permalink":"https://gandalfliang.github.io/tags/Loop-Hoisting/"},{"name":"RyuJIT","slug":"RyuJIT","permalink":"https://gandalfliang.github.io/tags/RyuJIT/"},{"name":"Loop Invariant Hoisting","slug":"Loop-Invariant-Hoisting","permalink":"https://gandalfliang.github.io/tags/Loop-Invariant-Hoisting/"}]},{"title":"Loop Hoisting","slug":"loop-hoisting","date":"2019-01-14T17:52:23.000Z","updated":"2019-01-17T11:17:32.045Z","comments":true,"path":"2019/01/15/loop-hoisting/","link":"","permalink":"https://gandalfliang.github.io/2019/01/15/loop-hoisting/","excerpt":"","text":"在上篇文章中，提到 Loop Hoisting ，这是一个常见的编译器优化项。我们总是能通过汇编代码等低级语言来“窥探”代码实际是怎么“指示”硬件运行的（这边文章不会涉及到详细的汇编内容，但是会用C#反编译后得到的汇编代码来辅助说明）。如果你看过我前面的几篇文章，会发现我用了大量反编译后的汇编代码来辅助说明，毕竟，千言不如实际的“证据”有说服力。 言归正传，Loop Hoisting，循环提升（粗略的翻译），编译器对循环代码中 loop-invariant 的代码提取出循环体外，防止循环结构内CPU对主存的重复读取。这很好理解，减少 CPU 与主存之间的 IO 次数，能有效提升程序的运行效率。观察下面的例子：12345678910111213141516171819202122namespace loop_hoisting&#123; class Program &#123; static void Main(string[] args) &#123; int[] array = new int[] &#123; 1, 2, 3 &#125;; int x = 10; int y = 11; LoopHoistTest(array, x, y); &#125; static void LoopHoistTest(int[] array, int x, int y) &#123; for (int i = 0; i &lt; array.Length; i++) &#123; array[i] = x + y; &#125; &#125; &#125;&#125; 很简单的一个例子，遍历列表且赋值。LoopHoistTest 函数的循环判断里，直接读取列表的长度，编译器在碰到这种情况，会对其进行优化，将对列表长度的读取进行提升（Hoist)，在循环体入口处缓存列表长度，并以此为判断依据，也就是说，从汇编代码的角度，循环判断始终去寄存器中读取缓存的列表长度信息，而不是每次都到主存中读取，以此来提到运行效率。另外，x+y很明显也是一段 loop-invariant 代码，相似地，编译器会将 x+y 的值缓存在某个通用寄存器内，并以此做赋值运算。编译器优化后的代码，就相当于：12345678910111213141516171819202122232425namespace loop_hoisting&#123; class Program &#123; static void Main(string[] args) &#123; int[] array = new int[] &#123; 1, 2, 3 &#125;; int x = 10; int y = 11; LoopHoistTest(array, x, y); &#125; static void LoopHoistTest(int[] array, int x, int y) &#123; int length = array.Length; int sum = x+y; for (int i = 0; i &lt; length; i++) &#123; array[i] = sum; &#125; &#125; &#125;&#125; 观察汇编代码：第一个红色框选的汇编代码：1mov ebx,dword ptr [rsi+8] //将rsi寄存器值加上8的偏移量指向的主存中的值复制到ebx通用寄存器 其中 rsi 寄存器中的值就是主存中 array 的地址，偏移的8位指向 length 字段，这段指令将数值中的长度信息储存在 ebx 通用寄存器中，并且在以后的 cmp 指令中使用，而不是直接与主存中的内容比较。1lea ebp,[rdx+r8] //将 rdx 和 r8 寄存器中的值相加并传送到 ebp 寄存器 其中，rdx 和 r8 寄存器分别储存着 x 和 y 的值，两者的和被储存在 ebp 寄存器，以后的指令都使用这个寄存器中的值，不再重复计算。 当然，并不是所有的循环代码都可以被优化，这涉及到 Loop-invariant 条件的判定，我们下篇文章再讲。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://gandalfliang.github.io/tags/C/"},{"name":"编译器优化","slug":"编译器优化","permalink":"https://gandalfliang.github.io/tags/编译器优化/"},{"name":"Loop Hoisting","slug":"Loop-Hoisting","permalink":"https://gandalfliang.github.io/tags/Loop-Hoisting/"}]},{"title":"C# 内存模型","slug":"csharp-memory-model-part-1","date":"2018-12-26T07:43:56.000Z","updated":"2019-01-08T02:51:22.627Z","comments":true,"path":"2018/12/26/csharp-memory-model-part-1/","link":"","permalink":"https://gandalfliang.github.io/2018/12/26/csharp-memory-model-part-1/","excerpt":"在 C# 的语言规范中 ECMA-334，对于Volatile关键字的描述： 15.5.4 Volatile fieldsWhen a field-declaration includes a volatile modifier, the fields introduced by that declaration are volatile fields. For non-volatile fields, optimization techniques that reorder instructions can lead to unexpected and unpredictable results in multi-threaded programs that access fields without synchronization such as that provided by the lock-statement (§13.13). These optimizations can beperformed by the compiler, by the run-time system, or by hardware. For volatile fields, such reordering optimizations are restricted: A read of a volatile field is called a volatile read. A volatile read has “acquire semantics”; that is, it is guaranteed to occur prior to any references to memory that occur after it in the instruction sequence. A write of a volatile field is called a volatile write. A volatile write has “release semantics”; that is, it is guaranteed to happen after any memory references prior to the write instruction in the instruction sequence. 简单来说，对于常规字段，由于代码优化而导致指令顺序改变，如果没有进行一定的同步控制，在多线程应用中可能会导致意想不到的结果，而造成这种意外的原因可能是编译器优化、运行时系统的优化或者因为硬件的原因（即CPU和主存储器的通信模型）。可变(volatile)字段会限制这种优化的发生，在这里引入两个定义： 可变读： 对于可变字段的读操作会获取语义。即，其可以保证对于可变字段的内存读取操作一定发生在其后内存操作指令的前面。进一步解释，与 Thread.MemoryBarrier 类似，获取语义会保证在读取可变字段指令前的指令可以跨越它出现在它后面，但是相反地，在它后面的指令不能跨越它出现在它的前面。例子： 12345678910111213141516171819class Volatile_class&#123; private int _a; private volatile int _b; private int _c; private void Call() &#123; int temp=_a; //由于_b是可变字段，这样可以保证编译器不会将temp2=_c的指令提前到其之前 //但是，可以将temp=_a提到其之后 int temp1=_b; int temp2=_c; ... &#125; private void OtherCall()&#123;...&#125;&#125; 可变写： 对于可变字段的写操作会释放语义。即，其可以保证对于可变字段的写操作发生在其前面指令执行之后，但是在它之后的指令可以跨域它提前执行。 X86_X64现代的 x86_x64 CPU 可以保证字段的读写都是 “volatile” 的，即你不会读取到旧的字段值，这是由 CPU 提供保证的。这样看起来好像与上面的描述存在矛盾，如果 CPU 可以保证所有字段的读写都是 volatile ,那为什么还需要在语言层面提供volatile关键字。其实这是两个不同的概念，CPU 从硬件层面上保证了对内存的读写是实时的，你不会读取到 Stale Value ,无论这个字段是常规字段还是可变字段。而语言层面上的 volatile 只是一个关键字，告诉编译器不能对该字段进行 instruction reorder 等可能导致多线程读写出现不符合预期结果的优化(暂且这样理解)。 参考这段代码：123456789101112131415161718class Program&#123; class infinity_loop &#123; public bool Terminated; &#125; static void Main(string[] args) &#123; var loop=new infinity_loop(); new Thread(()=&gt;&#123; loop.Terminated=true; &#125;).Start(); while(!loop.Terminated); &#125;&#125; 使用 dotnet core Release 模式运行这段代码，可以发现它永远也不会退出，分析汇编代码：","text":"在 C# 的语言规范中 ECMA-334，对于Volatile关键字的描述： 15.5.4 Volatile fieldsWhen a field-declaration includes a volatile modifier, the fields introduced by that declaration are volatile fields. For non-volatile fields, optimization techniques that reorder instructions can lead to unexpected and unpredictable results in multi-threaded programs that access fields without synchronization such as that provided by the lock-statement (§13.13). These optimizations can beperformed by the compiler, by the run-time system, or by hardware. For volatile fields, such reordering optimizations are restricted: A read of a volatile field is called a volatile read. A volatile read has “acquire semantics”; that is, it is guaranteed to occur prior to any references to memory that occur after it in the instruction sequence. A write of a volatile field is called a volatile write. A volatile write has “release semantics”; that is, it is guaranteed to happen after any memory references prior to the write instruction in the instruction sequence. 简单来说，对于常规字段，由于代码优化而导致指令顺序改变，如果没有进行一定的同步控制，在多线程应用中可能会导致意想不到的结果，而造成这种意外的原因可能是编译器优化、运行时系统的优化或者因为硬件的原因（即CPU和主存储器的通信模型）。可变(volatile)字段会限制这种优化的发生，在这里引入两个定义： 可变读： 对于可变字段的读操作会获取语义。即，其可以保证对于可变字段的内存读取操作一定发生在其后内存操作指令的前面。进一步解释，与 Thread.MemoryBarrier 类似，获取语义会保证在读取可变字段指令前的指令可以跨越它出现在它后面，但是相反地，在它后面的指令不能跨越它出现在它的前面。例子： 12345678910111213141516171819class Volatile_class&#123; private int _a; private volatile int _b; private int _c; private void Call() &#123; int temp=_a; //由于_b是可变字段，这样可以保证编译器不会将temp2=_c的指令提前到其之前 //但是，可以将temp=_a提到其之后 int temp1=_b; int temp2=_c; ... &#125; private void OtherCall()&#123;...&#125;&#125; 可变写： 对于可变字段的写操作会释放语义。即，其可以保证对于可变字段的写操作发生在其前面指令执行之后，但是在它之后的指令可以跨域它提前执行。 X86_X64现代的 x86_x64 CPU 可以保证字段的读写都是 “volatile” 的，即你不会读取到旧的字段值，这是由 CPU 提供保证的。这样看起来好像与上面的描述存在矛盾，如果 CPU 可以保证所有字段的读写都是 volatile ,那为什么还需要在语言层面提供volatile关键字。其实这是两个不同的概念，CPU 从硬件层面上保证了对内存的读写是实时的，你不会读取到 Stale Value ,无论这个字段是常规字段还是可变字段。而语言层面上的 volatile 只是一个关键字，告诉编译器不能对该字段进行 instruction reorder 等可能导致多线程读写出现不符合预期结果的优化(暂且这样理解)。 参考这段代码：123456789101112131415161718class Program&#123; class infinity_loop &#123; public bool Terminated; &#125; static void Main(string[] args) &#123; var loop=new infinity_loop(); new Thread(()=&gt;&#123; loop.Terminated=true; &#125;).Start(); while(!loop.Terminated); &#125;&#125; 使用 dotnet core Release 模式运行这段代码，可以发现它永远也不会退出，分析汇编代码： 可以看到红色框选位置，指令test一直在比较eax寄存器上的值，而该寄存器缓存了loop对象的Terminated值（为false)，汇编语言中，test是对两个参数进行AND操作，并设置对应的标志位。例如，如果两个值的AND操作为0，则ZF标志会被设置为1。而je指令是：根据特定标志位的情况进行跳转，其中就包括了ZF标志位。回到上面的汇编代码，可以知道 test eax eax 肯定会将ZF设置为1，则je就会导致死循环的产生。 尝试为Terminated值添加volatile关键字123456789101112131415161718class Program&#123; class infinity_loop &#123; public volatile bool Terminated;//可变字段 &#125; static void Main(string[] args) &#123; var loop=new infinity_loop(); new Thread(()=&gt;&#123; loop.Terminated=true; &#125;).Start(); while(!loop.Terminated); &#125;&#125; 运行代码，可以发现程序正常退出。再看汇编代码： 可以看到，这次是直接比较内存中字段的真实值，而不是寄存器上的值，这样循环会正常退出。 这是因为Loop Hoisting优化策略导致其中的循环判断经过JIT编译器优化后变成如下：12if(!loop.Terminated) while(true); 可以想象，这段优化过后的代码在多线程应用中是永远不会退出的。 最佳实践volatile 是一个比较晦涩，理解起来可能比较困难的概念，并不建议在不理解的情况下使用，你可以使用lock,Thread.MemoryBarrier或者Interlocked作为替代，不仅仅因为其中有过多的细节对开发人员隐藏，而且还要保证你的团队组员都理解其中的工作原理，特别地，volatile还会受不同环境影响，例如.NET Framework，编译器版本，甚至是硬件实现，这些都是需要考虑的因素。你要在使用 lock(或者其他)导致的性能开销和 volatile 引入导致的代码维护难度这两方面进行权衡。 参考文章:https://msdn.microsoft.com/en-us/magazine/jj883956.aspx","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://gandalfliang.github.io/tags/C/"},{"name":"Volatile","slug":"Volatile","permalink":"https://gandalfliang.github.io/tags/Volatile/"},{"name":"内存模型","slug":"内存模型","permalink":"https://gandalfliang.github.io/tags/内存模型/"}]},{"title":"C# 尾递归优化","slug":"tail-recursion","date":"2018-08-22T16:41:31.000Z","updated":"2019-01-08T02:51:22.641Z","comments":true,"path":"2018/08/23/tail-recursion/","link":"","permalink":"https://gandalfliang.github.io/2018/08/23/tail-recursion/","excerpt":"何为尾递归有时候我们使用递归来解决一些特定的问题，但是使用递归需要注意不要导致栈溢出，这是使用递归的一个常见问题，对于规模足够大的问题，使用递归必定会导致栈溢出。通常，我们可以通过尾递归进行优化，尾递归可以避免栈溢出的问题（暂且这样认为）。尾递归并不是什么新奇的东西，理解起来很简单，对于递归，如果上层调用的返回结果不依赖子调用的结果，那么，这就是一个尾递归。例如：123456789101112131415161718///这是一个简单的尾递归例子namespace tail&#123; class Program &#123; static void Main(string[] args) &#123; var test=RetrieveData(100000000000000); &#125; static long RetrieveData(long unit) &#123; if (unit == 0) return unit; return RetrieveData(--unit); &#125; &#125;&#125; 等等，好像有什么地方不对从上面的例子分析，代码依旧会导致栈溢出，不是吗？是的，聪明的你答对了。那为什么说尾递归可以避免栈溢出问题？当然，从刚才的结论看，这个问题提的并不准确，尾递归并不能避免栈溢出问题。仔细想想，尾递归结构和循环结构是类似的，上面的尾递归可以写成：","text":"何为尾递归有时候我们使用递归来解决一些特定的问题，但是使用递归需要注意不要导致栈溢出，这是使用递归的一个常见问题，对于规模足够大的问题，使用递归必定会导致栈溢出。通常，我们可以通过尾递归进行优化，尾递归可以避免栈溢出的问题（暂且这样认为）。尾递归并不是什么新奇的东西，理解起来很简单，对于递归，如果上层调用的返回结果不依赖子调用的结果，那么，这就是一个尾递归。例如：123456789101112131415161718///这是一个简单的尾递归例子namespace tail&#123; class Program &#123; static void Main(string[] args) &#123; var test=RetrieveData(100000000000000); &#125; static long RetrieveData(long unit) &#123; if (unit == 0) return unit; return RetrieveData(--unit); &#125; &#125;&#125; 等等，好像有什么地方不对从上面的例子分析，代码依旧会导致栈溢出，不是吗？是的，聪明的你答对了。那为什么说尾递归可以避免栈溢出问题？当然，从刚才的结论看，这个问题提的并不准确，尾递归并不能避免栈溢出问题。仔细想想，尾递归结构和循环结构是类似的，上面的尾递归可以写成：1234567//糟糕的例子，但是就这样吧static long RetriveData(long unit)&#123; for(long i=unit;i&lt;=0;i--) continue; return 0;&#125; 请忽略这个蠢函数什么都不做的事实。回到问题上，循环结构并不会导致栈溢出，基于这种结构上的对应，编译器可以对尾递归进行优化，重复使用栈上的递归函数，而不是每次调用都进行压栈操作，以此来避免栈溢出的问题。所以，完善的结论是：通过编译器优化，尾递归可以避免栈溢出的问题。 那么C#呢？不幸的是，对于微软的 C# Compiler， 只有 x64 Release 才有尾递归优化。作为对比，我们分析其与 x86 Release 下编译后的代码的区别，看看编译器是如何优化尾递归调用的。 分析两者的 IL 代码，可以发现它们并没有什么区别，所以，真正进行优化操作的是 JIT 编译器。分析两者的汇编代码： 可以看出，在 ASM_x64 中，递归调用没有重复压栈，而是在栈内跳转，类似于循环结构，以此来避免栈溢出问题。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://gandalfliang.github.io/tags/C/"},{"name":"尾递归","slug":"尾递归","permalink":"https://gandalfliang.github.io/tags/尾递归/"}]},{"title":"业务逻辑中的 Filter","slug":"filtering-in-business-logic","date":"2018-07-16T03:50:00.000Z","updated":"2018-08-23T01:36:32.125Z","comments":true,"path":"2018/07/16/filtering-in-business-logic/","link":"","permalink":"https://gandalfliang.github.io/2018/07/16/filtering-in-business-logic/","excerpt":"","text":"Pipe and Filter在一些应用的开发场景中，例如，大量的数据处理、需要对数据进行大量的转换和过滤，使用管道和Filter是一个很好的选择。对于这种应用场景，一般都需要处理业务足够灵活，并且足够健壮。想象一下，为了实现相应的过滤功能，使用大量的if或者switch case,日后维护这套代码的人估计也会抓狂的吧，单元测试编写起来，应该也够呛吧。 用Filter来处理业务Filter一般都被认为是用来处理数据的，其实，更近一步，用来”处理”业务，也不失为一种好办法。当然，这里的处理，并不是说在Filter中执行业务，考虑到业务都是一些耗时（但不绝对）的操作，在管道中处理业务是不对的，这样会堵塞整条管道。相反地，我们的业务依赖管道中的数据，我们希望在数据处理的过程中，由数据的处理来触发特定的业务，因此，我们定义一种BusinessFilter，其不对数据进行处理，而是作为一种窥探，“假装”自己是在进行数据处理，实际是根据数据的实际来通知外界做相应的业务而已。 灵活性正如上图的结构，搭积木式的链式结构可以根据业务的调整进行对应的调整，不同的业务可以在通道中穿插。从另一个方面可以看出，我们设计Filter的时候，保持它的独立性是至关重要的，一个Filter完成一个工作，而且不受其他Filter影响是保持整个链式结构灵活的关键。 健壮性一般来说，管道/Filter结构一旦确定，会做大调整的几率都不高。由于Filter的存在，所有的变动在改动之前就可以确定影响范围，而且可以限制调整带来的结构变动。 存在的问题 几乎所有的Pipe/Filter结构都是线性结构，这种情况限制了async/await的应用 如果一个Filter只接受一种数据类型，那么存在的数据转换会降低我们系统的性能，特别地，如果是C#，进行引用类型和值类型的转换，频繁的装箱拆箱也会降低我们系统的性能；为了解决这种问题，限制Filter可接受的数据类型，这样就不能随意连接Filter到所有数据类型，通用性降低。 …","categories":[],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://gandalfliang.github.io/tags/design-pattern/"},{"name":"filter","slug":"filter","permalink":"https://gandalfliang.github.io/tags/filter/"}]},{"title":"使用 IDE 编译调试 Mlt framework","slug":"debugging-mlt","date":"2018-06-01T05:32:41.000Z","updated":"2018-07-16T02:05:26.961Z","comments":true,"path":"2018/06/01/debugging-mlt/","link":"","permalink":"https://gandalfliang.github.io/2018/06/01/debugging-mlt/","excerpt":"","text":"Mlt framework 是一个开源跨平台的多媒体处理框架，使用模块化的设计，集成了大量的业界领先的视频处理框架，如ffmpeg，良好的设计，可以方便的集成自己的模块进去，利用它，你可以实现自己的 Adobe Premiere 等非线性多媒体编辑软件或者视频播放器，简单几句代码为视频添加炫酷的转场效果和滤镜。 由于跨平台，项目通过configure的方式来管理工程，对于学习来说多媒体框架来说，调试起来并不方便，我整理了CMake的脚本，可以通过cmake来生成我们熟悉的 Visual Studio 或者 Xcode工程，方便调试。 在阅读下面文章之前，请确保你有一定的 MinGW 工具链使用经验。 下载源码https://github.com/gandalfliang/mlt分支：cmake 配置环境对于 Windows 平台： cmake MinGW msys2 Windows SDK 确保MinGW和msys2里的工具链路径在系统变量PATH中 Mac 平台： Xcode Bootstrap在工程跟目录，运行脚本（如果是 Windows 平台，从开发者命令行工具运行）：1py bootstrap.py 如果一切顺利，工程文件将会在 build/win32 或者 build/mac 下。脚本运行要拉取ffmpeg的源码并configure，这是一个耗时的工作。在Windows平台下configure ffmpeg将是一个漫长的等待，没事的话，去喝杯咖啡，或者有空的时候在命令窗里敲一下enter键，可能会有收获哦。 完成后，你就可以愉快的调试这个框架了。","categories":[],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://gandalfliang.github.io/tags/Visual-Studio/"},{"name":"Mlt Framework","slug":"Mlt-Framework","permalink":"https://gandalfliang.github.io/tags/Mlt-Framework/"},{"name":"Xcode","slug":"Xcode","permalink":"https://gandalfliang.github.io/tags/Xcode/"}]},{"title":"Debug Mlt Framework in VSCode","slug":"debug_mlt_vscode","date":"2018-04-16T17:21:38.000Z","updated":"2019-01-10T12:18:57.092Z","comments":true,"path":"2018/04/17/debug_mlt_vscode/","link":"","permalink":"https://gandalfliang.github.io/2018/04/17/debug_mlt_vscode/","excerpt":"","text":"Debugging Mlt framework in VSCode Crossing platform with built in tool chain Coming up soon (maybe)","categories":[{"name":"图片","slug":"图片","permalink":"https://gandalfliang.github.io/categories/图片/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://gandalfliang.github.io/tags/VSCode/"},{"name":"Mlt Framework","slug":"Mlt-Framework","permalink":"https://gandalfliang.github.io/tags/Mlt-Framework/"}]},{"title":"Gitsoler","slug":"Gitsoler1_1","date":"2018-03-21T03:01:38.000Z","updated":"2018-03-21T12:58:07.022Z","comments":true,"path":"2018/03/21/Gitsoler1_1/","link":"","permalink":"https://gandalfliang.github.io/2018/03/21/Gitsoler1_1/","excerpt":"","text":"Gitsoler 1.1 - Split View supported: https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler","categories":[{"name":"工具","slug":"工具","permalink":"https://gandalfliang.github.io/categories/工具/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://gandalfliang.github.io/tags/Visual-Studio/"},{"name":"Extension","slug":"Extension","permalink":"https://gandalfliang.github.io/tags/Extension/"}]},{"title":"【翻译】关于 WPF 透明窗口的内存占用","slug":"transparent_4k_window.translate","date":"2018-02-16T15:01:38.000Z","updated":"2018-05-28T10:38:02.459Z","comments":true,"path":"2018/02/16/transparent_4k_window.translate/","link":"","permalink":"https://gandalfliang.github.io/2018/02/16/transparent_4k_window.translate/","excerpt":"","text":"翻译自己的文章才是最骚的。。。 Origin Post 要实现一个透明的 WPF 窗口？多么简单的一个任务啊！只要设置 AllowTransparency 和 WindowStyle，你可以在毫秒间完成这个任务。 AllowTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Background=&quot;Transparent&quot; 正确吧？当然。但是（你懂得），打开你的任务管理器看看，简单的任务通常会带来大量的内存占用，特别是4K分辨率的透明窗口。100+ MB的内存被浪费了，就只为了显示一个空白的透明窗口！这是不可接受的。一年前，如果你说：”谁关心内存呀，现在的内存条太便宜了”，你可能是对的。但是查查这一年内存条的价格走向，它们现在贵上天了。 WPF 透明窗口的有趣小真相 内存占用随着窗口尺寸增大而增加 Win32 窗口没有这样的问题 等等，什么？窗口越大，内存消耗的更多？嗯。。。这看起来很熟悉嘛，就像一个Bitmap。知道现在，我们并不知道 WPF 是如何处理透明窗口的，但是这种症状显示它就好像直接将整个桌面作为一个位图，然后窗口用这张位图的重叠部分作为其背景来更新自己，让它看起来是“透明”的。多么聪明的做法呀。。。在 WPF 刚刚发布的那些日子里，低分辨率的计算机屏幕占据主流位置，即使在今天，大多数的笔记本电脑依然带着一块1366*768分辨率的屏幕被推向市场（离谱吧）。让我们唾弃那些OEM厂商讲的毫无根据的废话并且思考一下运行在高分辨率下的程序的情况。 内存并不是免费的，不要浪费之很显然，浪费100+MB的内存来显示一个4K的透明窗口是不可接受的，特别是和 Win32 窗口只占用10+MB的内存进行比较时。这差距让 WPF 看起来蠢透了。抱怨已经够多了，想想对此我们能做什么呢？我可不想用C++和GDI将我的UI代码重写一遍，这太没效率并且也跟不上时代，况且，没人会为此“区区小事”去放弃他们漂亮、易于维护的Xaml UI代码。 使用 Win32 承载 WPF 内容好吧，确实，没人愿意为了区区90MB内存去重写它们的UI。与使用C++重写UI所耗费的精力相比，这个内存的占用差距看起来是可以接受的（#笑脸）。但是请记住，我们一如既往的可以在 Win32 窗口中承载 WPF 的内容。例如，我们想创建一个全屏、半透明背景带着非透明内容的对话框。为了规避 WPF 透明窗口的内存问题，我们可以使用 Win32 创建一个半透明的窗口：123456789101112131415DWORD Flags1 = WS_EX_LAYERED;DWORD Flags2 = WS_POPUP;HWND hWnd = CreateWindowEx(Flags1,szWindowClass, szTitle, Flags2, CW_USEDEFAULT, 0, 3840,2160, nullptr, nullptr, hInstance, nullptr);SetLayeredWindowAttributes(hWnd, RRR, (BYTE)125, LWA_ALPHA);ShowWindow(hWnd, nCmdShow);UpdateWindow(hWnd);case WM_ERASEBKGND: RECT rect; GetClientRect(hWnd, &amp;rect); FillRect((HDC)wParam, &amp;rect, CreateSolidBrush(RGB(0, 0, 0))); break; 通过启用 C++/CLI，我们可以直接访问 WPF 内容 12345678910111213141516171819202122namespace ManagedCode&#123; using namespace System; using namespace System::Windows; using namespace System::Windows::Interop; using namespace System::Windows::Media; HWND GetHwnd(HWND parent, int x, int y, int width, int height) &#123; HwndSource^ source = gcnew HwndSource( 0, // class style WS_VISIBLE | WS_CHILD, // style 0, // exstyle x, y, width, height, \"hi\", // NAME IntPtr(parent) // parent window ); UIElement^ page = gcnew ManagedContent::WPFContent(); source-&gt;RootVisual = page; return (HWND)source-&gt;Handle.ToPointer(); &#125;&#125; 最后 12//managed contentManagedCode::GetHwnd(hWnd, 0, 0, 200, 200); 由于 WPF 和 GDI 背后的技术不尽相同，还有更多的工作需要做来解决不可避免的透明通道问题，但是，为了方便，你始终可以使用 Popup 来实现你的目标。 Macbook Pro 2016 的键盘真垃圾。。。。。。","categories":[{"name":"翻译","slug":"翻译","permalink":"https://gandalfliang.github.io/categories/翻译/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://gandalfliang.github.io/tags/WPF/"},{"name":"翻译","slug":"翻译","permalink":"https://gandalfliang.github.io/tags/翻译/"},{"name":"LayeredWindow","slug":"LayeredWindow","permalink":"https://gandalfliang.github.io/tags/LayeredWindow/"},{"name":"Performance","slug":"Performance","permalink":"https://gandalfliang.github.io/tags/Performance/"}]},{"title":"Light Weighted DropshadowEffect","slug":"lightweighted_shadoweffect","date":"2018-02-12T05:58:27.000Z","updated":"2018-05-28T10:38:02.453Z","comments":true,"path":"2018/02/12/lightweighted_shadoweffect/","link":"","permalink":"https://gandalfliang.github.io/2018/02/12/lightweighted_shadoweffect/","excerpt":"","text":"Let’s create a light weighted wpf drop shadow effect, considering that the origin one performs badly in some special occasions.As I mentioned before (check it out), the original WPF DropShadow Effect can cause severe preformance problem. Due to the “flaw” M$FT brought to the HLSL support for WPF, the Effect class that implements the visual effect creates and destroy GPU resource each frame, which is the worst thing you could do with GPU resources. So, what about implementing a custom shadow effect to avoid it? This sounds interesting. – 春节补充","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"OpenCL","slug":"OpenCL","permalink":"https://gandalfliang.github.io/tags/OpenCL/"},{"name":"高性能计算","slug":"高性能计算","permalink":"https://gandalfliang.github.io/tags/高性能计算/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gandalfliang.github.io/tags/图像处理/"}]},{"title":"关于 WPF 透明窗口的内存占用","slug":"transparent_4k_window","date":"2018-01-17T03:01:38.000Z","updated":"2018-02-12T07:24:25.848Z","comments":true,"path":"2018/01/17/transparent_4k_window/","link":"","permalink":"https://gandalfliang.github.io/2018/01/17/transparent_4k_window/","excerpt":"","text":"要实现一个透明的 WPF 窗口？What an easy task! By setting AllowTransparency and WindowStyle, you could finish it in seconds. AllowTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Background=&quot;Transparent&quot; Correct? Of course. However (you know this is coming), look at your task manager, easy task comes with large memory consumption, especially for 4K transparent window. 100+ MB ram are wasted for just showing an empty, transparent window! That’s unacceptable. A year ago, you might be right saying “Who cares about RAM, they are cheap as hell”, but check out the price they’ve grown over this year, they are expensive as hell now. Fun fact of WPF transparent window RAM usage increase as window size enlarge Win32 window has no such problem Wait, what? The larger the window is, the more RAM it consumes? Hmmmmm… this looks familiar, just like a Bitmap. For now, we don’t know how WPF handles transparent window, but the symptom shows that it’s like using the whole screen as a bitmap and the window updating itself with portion of that bitmap, making it “transparent”. What a smart move…Back in the days when WPF was first released, low screen resolution was the main stream. Even today, most laptops still are shipping with a monitor of 1366*768 (ridiculous, right?). Let’s despise the nonsense the OEM told us and think about program running in computers with higher screen resolution. RAM is not free, do not waste itObviously, costing 100+ mb of ram for showing a transparent window in 4K is unacceptable, especially compared with Win32 transparent window, which costs only 10+ mb. The gap between them makes WPF look dump.Enough complaining, what can we do about it? I don’t want to write UI code with GDI using C++, that’s inefficient and not modern, plus, no one would abandon their beautiful, easy to maintain xaml UI code for this. Hosting WPF content in Win32 WindowWell, indeed, no one would rewrite their UI code for just about 90mb of RAM. Compared with the work needed to rewrite C++ UI code, the RAM consumption gap seems acceptable (#smile face). But please remember, we can always host WPF content in win32 window.Let say, we want to create a full screen notification dialog with semi-transparent background and apaque notication content in the center. To avoid the WPF ram problem, we create a semi-transparent window using win32:123456789101112131415DWORD Flags1 = WS_EX_LAYERED;DWORD Flags2 = WS_POPUP;HWND hWnd = CreateWindowEx(Flags1,szWindowClass, szTitle, Flags2, CW_USEDEFAULT, 0, 3840,2160, nullptr, nullptr, hInstance, nullptr);SetLayeredWindowAttributes(hWnd, RRR, (BYTE)125, LWA_ALPHA);ShowWindow(hWnd, nCmdShow);UpdateWindow(hWnd);case WM_ERASEBKGND: RECT rect; GetClientRect(hWnd, &amp;rect); FillRect((HDC)wParam, &amp;rect, CreateSolidBrush(RGB(0, 0, 0))); break; By enabling C++/CLI, we can access WPF content directly 12345678910111213141516171819202122namespace ManagedCode&#123; using namespace System; using namespace System::Windows; using namespace System::Windows::Interop; using namespace System::Windows::Media; HWND GetHwnd(HWND parent, int x, int y, int width, int height) &#123; HwndSource^ source = gcnew HwndSource( 0, // class style WS_VISIBLE | WS_CHILD, // style 0, // exstyle x, y, width, height, \"hi\", // NAME IntPtr(parent) // parent window ); UIElement^ page = gcnew ManagedContent::WPFContent(); source-&gt;RootVisual = page; return (HWND)source-&gt;Handle.ToPointer(); &#125;&#125; and finally 12//managed contentManagedCode::GetHwnd(hWnd, 0, 0, 200, 200); Due to the different technologies behind WPF and GDI, more work needed to be done for the unavoidable alpha blending problem, but, you can use wpf popup to achieve your goal for short.","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://gandalfliang.github.io/tags/WPF/"},{"name":"LayeredWindow","slug":"LayeredWindow","permalink":"https://gandalfliang.github.io/tags/LayeredWindow/"},{"name":"Performance","slug":"Performance","permalink":"https://gandalfliang.github.io/tags/Performance/"}]},{"title":"使用 OpenCL 实现图片高斯模糊","slug":"gaussian_blur_opencl","date":"2018-01-02T05:58:27.000Z","updated":"2019-01-10T12:18:34.069Z","comments":true,"path":"2018/01/02/gaussian_blur_opencl/","link":"","permalink":"https://gandalfliang.github.io/2018/01/02/gaussian_blur_opencl/","excerpt":"","text":"高斯模糊（ https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A ）是一种常见的图像处理算法，使用高斯分布与图像做卷积，得到模糊的效果。其二维定义： σ是正态分布的标准偏差。在应用的时候，假设σ为2.5。对于模糊半径为1，则高斯矩阵为3*3的一个矩阵，以[1,1]为中心，带入公式计算高斯矩阵的值，得到： 0.0216996633 0.0235069655 0.0216996633 0.0235069655 0.0254647918 0.0235069655 0.0216996633 0.0235069655 0.0216996633 他们的和为 0.206291318，我们需要他们的和为1，因此与总和相除得到： 0.105189413 0.113950342 0.105189413 0.113950342 0.123440929 0.113950342 0.105189413 0.113950342 0.105189413 根据这个矩阵，对图像的每个像素点进行计算，计算的九个点的各rgb分量之和就是最终像素的rgb分量。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//计算高斯矩阵private void ComputeWeightMatrix()&#123; var center = Radius; var conBase = 2 * Math.Pow(Variance, 2); var conRoot = 1 / (Math.PI * conBase); float sum = 0f; for (int x = -Radius; x &lt;= Radius; x++) &#123; for (int y = Radius; y &gt;= -Radius; y--) &#123; var weight = conRoot * Math.Pow(Math.E, -(x * x + y * y) / conBase); _matrix[GridPosToArrayIndex(x, y, center, Radius)] = (float)weight; sum += (float)weight; &#125; &#125; for (int i = 0; i &lt; _matrix.Length; i++) &#123; _matrix[i] /= sum; &#125;&#125;//Computepublic void Compute(string imageFile)&#123; using (var bitmap = new Bitmap(imageFile)) &#123; var datas = bitmap.LockBits(new Rectangle(new Point(), new Size(bitmap.Width, bitmap.Height)),ImageLockMode.ReadOnly,bitmap.PixelFormat); var dataSize = datas.Stride * datas.Height; var argbs = new byte[dataSize]; var dsts = new byte[dataSize]; int matrixWidth = Radius * 2 + 1; Marshal.Copy(datas.Scan0, argbs, 0, dataSize); Stopwatch sw=Stopwatch.StartNew(); for (int y = 0; y &lt; bitmap.Height; y++) &#123; for (int x = 0; x &lt; bitmap.Width; x++) &#123; float sumA = 0; float sumR = 0; float sumG = 0; float sumB=0; for (int i = 0; i &lt; _matrix.Length; i++) &#123; var pos = transform_pos(x, y, matrixWidth, bitmap.Width, bitmap.Height, Radius, i); var position = pos.Y * datas.Stride + pos.X*4; sumR += argbs[position] * _matrix[i]; sumG += argbs[position + 1] * _matrix[i]; sumB += argbs[position + 2] * _matrix[i]; sumA += argbs[position + 3] * _matrix[i]; &#125; var dstPos = y * datas.Stride + x * 4; dsts[dstPos] = (byte)sumR; dsts[dstPos+1] = (byte)sumG; dsts[dstPos+2] = (byte)sumB; dsts[dstPos+3] = (byte)sumA; &#125; &#125; bitmap.UnlockBits(datas); var elapse = sw.Elapsed; Console.WriteLine($\"Costing: &#123;elapse&#125;\"); Debug.WriteLine($\"Costing: &#123;elapse&#125;\"); var handle = GCHandle.Alloc(dsts, GCHandleType.Pinned); using (var dstBmp = new Bitmap(datas.Width, datas.Height, datas.Stride, bitmap.PixelFormat, handle.AddrOfPinnedObject())) &#123; dstBmp.Save(\"processed_normal.bmp\"); &#125; handle.Free(); &#125;&#125; 当然，这样能完成工作，但是耗时太长，对于3000*1920尺寸的图片处理需要2分51秒（Intel Core i7-4770)，这显然是不可接受的。对于这种分别计算每个像素，且各像素间互不干扰的问题，使用OpenCL可以大幅降低时间消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* OpenCL 高斯模糊代码 Copyright Gandalfliang*/ inline int2 transform_pos(int centerX,int centerY,int matrixWidth,int radius,int index)&#123; int x=index%matrixWidth; int offsetX=x-(radius+1); int y=index/matrixWidth; int offsetY=radius-y; return (int2)(centerX+offsetX,centerY-offsetY);&#125;;const sampler_t sampler_img=CLK_NORMALIZED_COORDS_FALSE|CLK_ADDRESS_CLAMP_TO_EDGE;//opencl kernel 代码kernel void gaussian_blur( read_only image2d_t src, global write_only char* dst, global read_only float* matrix, read_only int radius, read_only int width)&#123; int x=get_global_id(0); int y=get_global_id(1); float sumR,sumG,sumB,sumA; int matrixWidth=radius*2+1; int matrix_size=pow(matrixWidth,2); for(int i=0;i&lt;matrix_size;i++) &#123; int2 pix=transform_pos(x,y,matrixWidth,radius,i); uint4 rgba = read_imageui(src,sampler_img,pix); sumR+=rgba.x*matrix[i]; sumG+=rgba.y*matrix[i]; sumB+=rgba.z*matrix[i]; sumA+=rgba.w*matrix[i]; &#125; int loc=y*width*4+x*4; dst[loc]=sumR; dst[loc+1]=sumG; dst[loc+2]=sumB; dst[loc+3]=sumA;&#125; Host代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void Compute_cl(string imageFile)&#123; //选取设备 var platform = ComputePlatform.Platforms.FirstOrDefault(); var device = platform.Devices.FirstOrDefault(); //设置相关上下文 var properties = new ComputeContextPropertyList(platform); var context = new ComputeContext(new[] &#123;device&#125;, properties, null, IntPtr.Zero); //命令队列，用于控制执行的代码 ComputeCommandQueue commands = new ComputeCommandQueue(context, context.Devices[0], ComputeCommandQueueFlags.None); //读取opencl代码 var code = File.ReadAllText(@\"gaussianblur.cl\"); //编译 var program = new ComputeProgram(context, code); try &#123; program.Build(new[] &#123;device&#125;, null, null, IntPtr.Zero); &#125; catch (Exception ex) &#123; throw; &#125; var images = CreateImageFromBitmap(imageFile, context, ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer); //创建核心代码，就是cl代码中以kernel标识的函数 var kernel = program.CreateKernel(\"gaussian_blur\"); //矩阵规模 //储存计算结果的数组 //创建的核心代码函数以这种方式来传参 var resultBuffer=new ComputeBuffer&lt;char&gt;(context,ComputeMemoryFlags.WriteOnly, dstBytes.Length); kernel.SetMemoryArgument(0, images); kernel.SetMemoryArgument(1, resultBuffer); kernel.SetMemoryArgument(2, new ComputeBuffer&lt;float&gt;(context,ComputeMemoryFlags.ReadOnly|ComputeMemoryFlags.CopyHostPointer,_matrix)); kernel.SetValueArgument(3, Radius); kernel.SetValueArgument(4, (int)images.Width); Console.WriteLine($\"运行平台: &#123;platform.Name&#125;\\n运行设备： &#123;device.Name&#125;\\n\"); Stopwatch sw = Stopwatch.StartNew(); var climg = images; //执行代码 commands.Execute(kernel, null, new long[] &#123;climg.Width, climg.Height&#125;, null, null); //read data char[] resultArray = new char[dstBytes.Length]; var arrHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned); commands.Read(resultBuffer, true, 0, dstBytes.Length, arrHandle.AddrOfPinnedObject(), null); //commands.ReadFromImage(images.Item2, processeddata.Scan0, true, null); var resultHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned); var bmp=new Bitmap(climg.Width,climg.Height, climg.Width*4, PixelFormat.Format32bppArgb, resultHandle.AddrOfPinnedObject()); var elapsed = sw.Elapsed; Console.WriteLine($\"耗时: &#123;elapsed.TotalMilliseconds&#125; ms\\n\"); kernel.Dispose(); bmp.Save(\"processed_cl.bmp\");&#125; 相同尺寸的图片处理，使用 Intel Core i7-4770 自带的核显 HD4600 处理，耗时只需要164毫秒。 以下是相关测试结果：1234567891011121314151617181920212223运行平台: Intel(R) OpenCL运行设备： Intel(R) HD Graphics 4600处理图片尺寸：790*501OpenCL处理耗时: 13.6597 ms处理图片尺寸：790*501常规方法耗时: 11482.9402 ms运行平台: Intel(R) OpenCL运行设备： Intel(R) HD Graphics 4600处理图片尺寸：1339*693OpenCL处理耗时: 33.0095 ms处理图片尺寸：1339*693常规方法耗时: 26908.9926 ms运行平台: Intel(R) OpenCL运行设备： Intel(R) HD Graphics 4600处理图片尺寸：1920*1080OpenCL处理耗时: 51.3885 ms处理图片尺寸：1920*1080常规方法耗时: 60147.3815 ms 当然，常规方法都只使用了单线程，还未发挥多核CPU的威力，然而，可以预见的是，即使是使用多线程，提升也是有限的。 原图：高斯模糊： 代码： https://github.com/gandalfliang/cloo_netstandard/tree/temp Update: 在nVidia的环境下会导致处理后的图片出现花屏现象，估计是cl代码的问题，又或者是nVidia的驱动有问题？下次再更新","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"OpenCL","slug":"OpenCL","permalink":"https://gandalfliang.github.io/tags/OpenCL/"},{"name":"高性能计算","slug":"高性能计算","permalink":"https://gandalfliang.github.io/tags/高性能计算/"},{"name":"高斯模糊","slug":"高斯模糊","permalink":"https://gandalfliang.github.io/tags/高斯模糊/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gandalfliang.github.io/tags/图像处理/"}]},{"title":".NET Standard CLOO","slug":"cloo_net_standard","date":"2017-12-25T03:01:38.000Z","updated":"2018-02-12T07:23:20.297Z","comments":true,"path":"2017/12/25/cloo_net_standard/","link":"","permalink":"https://gandalfliang.github.io/2017/12/25/cloo_net_standard/","excerpt":"","text":"鉴于 .NET Standard 2.0 已经支持大量的.NET api，移植CLOO已经是毫无难度的一件事情 Github CLOO使用p/invoke方式调用opencl api，但是对于不同平台下，opencl 的名称并不一致，例如在linux下为libOpenCL.so，Windows下为OpenCL.dll，且 .NET Standard 没有提供 Mono 类似的 dllmap 模式，因此，现在来说还不能达到用一个package，在所有平台引用的目的。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"CLOO","slug":"CLOO","permalink":"https://gandalfliang.github.io/tags/CLOO/"},{"name":"NET Standard","slug":"NET-Standard","permalink":"https://gandalfliang.github.io/tags/NET-Standard/"}]},{"title":"Gitsoler","slug":"Gitsoler","date":"2017-12-16T03:01:38.000Z","updated":"2018-02-12T07:23:44.405Z","comments":true,"path":"2017/12/16/Gitsoler/","link":"","permalink":"https://gandalfliang.github.io/2017/12/16/Gitsoler/","excerpt":"","text":"Gitsoler - a Visual Studio extension, now goes public: https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler","categories":[{"name":"工具","slug":"工具","permalink":"https://gandalfliang.github.io/categories/工具/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://gandalfliang.github.io/tags/Visual-Studio/"},{"name":"Extension","slug":"Extension","permalink":"https://gandalfliang.github.io/tags/Extension/"}]},{"title":"“阻断疗法” - 拯救 WPF 启动过程中发生设备热插拔导致触摸失效问题","slug":"WPFLostTouchCapability","date":"2017-12-02T05:58:27.000Z","updated":"2019-01-10T12:23:45.678Z","comments":true,"path":"2017/12/02/WPFLostTouchCapability/","link":"","permalink":"https://gandalfliang.github.io/2017/12/02/WPFLostTouchCapability/","excerpt":"","text":"如果你在WPF程序启动过程中进行设备热插拔（例如，插入一个U盘，一个USB摄像头），那么你的WPF程序很有可能失去所有触摸消息响应，通过 Tablet.TabletDevices.Count 检查当前程序的挂靠触摸设备，发现为0。有趣的是，如果你将触摸线重新插拔后，程序恢复正常。所以，这是WPF的Bug，微软的锅。那么这个锅的根本原因是啥？有兴趣的可以调试 .net framework 源码，这里没有深究。如上面讲到，触摸线重新插拔就可以解决这个问题，但是，导致这个问题的热插拔设备也不是触摸设备啊，只是一个普通的U盘，反过来想，如果导致问题的不是触摸设备热插拔，反而触摸设备的热插拔能够修复这个问题，那我能不能“模拟”一下触摸设备的热插拔事件呢？在这篇文章里描述怎样模拟触摸设备移除事件来达到禁用WPF触摸的效果,反过来试试，通过 OnTabletAdded 事件看看能不能发生奇迹。然而，奇迹并没有发生，所以这个方法不行。既然模拟设备添加事件的方法不行，那我从源头阻挡这个问题的发生：启动过程中不要处理设备变动事件。那么问题来了，我想要阻断 win32 WM 事件通知，必须要拿到一个窗口句柄呀，但是在 mainwindow show 出来的时候，这个问题已经发生了，这个时候的阻断已经没有效果了，一定要程序启动一开始做阻断。进一步搜索，这里https://stackoverflow.com/questions/38642479/how-to-disable-wpf-tablet-support-in-surface-4-pro 是一个突破口： WPF does not register to these messages on the applications MainWindow, but through a hidden windows named “SystemResources…” which is created for each application instance. So handling those messages on the MainWindow (which would be easy) does not help here. 相信看到这里，聪明的你已经知道怎么做了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class WPFTouchUtil &#123; //添加钩子，阻断设备改动消息 public static void HandleDeviceChangedWM() &#123; // hook into internal class SystemResources to keep it from updating the TabletDevices on system events object hwndWrapper = GetSystemResourcesHwnd(); if (hwndWrapper != null) &#123; // invoke hwndWrapper.AddHook( .. our method ..) var internalHwndWrapperType = hwndWrapper.GetType(); // if the delegate is already set, we have already added the hook. if (_handleAndHideMessageDelegate == null) &#123; // create the internal delegate that will hook into the window messages // need to hold a reference to that one, because internally the delegate is stored through a WeakReference object var internalHwndWrapperHookDelegate = internalHwndWrapperType.Assembly.GetType(\"MS.Win32.HwndWrapperHook\"); var handleAndHideMessagesHandle = typeof(WPFTouchUtil).GetMethod(nameof(HandleAndHideMessages), BindingFlags.Static | BindingFlags.NonPublic); _handleAndHideMessageDelegate = Delegate.CreateDelegate(internalHwndWrapperHookDelegate, handleAndHideMessagesHandle); // add a delegate that handles WM_TABLET_ADD internalHwndWrapperType.InvokeMember(\"AddHook\", BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.Public, null, hwndWrapper, new object[] &#123; _handleAndHideMessageDelegate &#125;); &#125; &#125; &#125; //移除钩子，恢复状态 public static void RestoreDeviceChangedWM() &#123; object hwndWrapper = GetSystemResourcesHwnd(); if (hwndWrapper != null) &#123; var internalHwndWrapperType = hwndWrapper.GetType(); internalHwndWrapperType.InvokeMember(\"RemoveHook\", BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.Public, null, hwndWrapper, new object[] &#123;_handleAndHideMessageDelegate&#125;); &#125; &#125; private static Delegate _handleAndHideMessageDelegate = null; private static object GetSystemResourcesHwnd() &#123; var internalSystemResourcesType = typeof(Application).Assembly.GetType(\"System.Windows.SystemResources\"); // get HwndWrapper from internal property SystemRessources.Hwnd; var hwndWrapper = internalSystemResourcesType.InvokeMember(\"Hwnd\", BindingFlags.GetProperty | BindingFlags.Static | BindingFlags.NonPublic, null, null, null); return hwndWrapper; &#125; private static IntPtr HandleAndHideMessages(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled) &#123; if (msg == (int)WindowMessage.WM_DEVICECHANGE) &#123; handled = true; &#125; return IntPtr.Zero; &#125; enum WindowMessage : int &#123; WM_DEVICECHANGE = 0x0219 &#125; &#125; 在程序刚启动的时候添加“阻断”，启动流程过后，不要忘了恢复状态。缺陷，如果程序启动过程中，真的发生了触摸设备变动，也会被阻断。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://gandalfliang.github.io/tags/WPF/"},{"name":"BUG","slug":"BUG","permalink":"https://gandalfliang.github.io/tags/BUG/"}]},{"title":"Timelapse#2","slug":"Timelapse2","date":"2017-10-20T12:33:39.000Z","updated":"2019-01-10T12:31:15.733Z","comments":true,"path":"2017/10/20/Timelapse2/","link":"","permalink":"https://gandalfliang.github.io/2017/10/20/Timelapse2/","excerpt":"","text":"Lens: Nikkor 24-70mm F2.8f2.8 70mm ISO400","categories":[{"name":"摄影","slug":"摄影","permalink":"https://gandalfliang.github.io/categories/摄影/"}],"tags":[{"name":"Timelapse","slug":"Timelapse","permalink":"https://gandalfliang.github.io/tags/Timelapse/"},{"name":"Nikon","slug":"Nikon","permalink":"https://gandalfliang.github.io/tags/Nikon/"},{"name":"Guangzhou","slug":"Guangzhou","permalink":"https://gandalfliang.github.io/tags/Guangzhou/"},{"name":"单反","slug":"单反","permalink":"https://gandalfliang.github.io/tags/单反/"},{"name":"Video","slug":"Video","permalink":"https://gandalfliang.github.io/tags/Video/"}]},{"title":"WPF 渲染小结","slug":"WPF_rendering_perf","date":"2017-09-20T04:19:30.000Z","updated":"2019-01-10T12:23:20.533Z","comments":true,"path":"2017/09/20/WPF_rendering_perf/","link":"","permalink":"https://gandalfliang.github.io/2017/09/20/WPF_rendering_perf/","excerpt":"","text":"在上一篇文章D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践最后，提到DropShadowEffect严重影响到D3DImage的渲染性能问题，导致程序在渲染8分屏（8个远端视频）的时候，出现严重的性能下降，渲染卡顿。要知道，在使用原生窗口渲染方案渲染8分屏，CPU占用和内存占用也不过25%和~200Mb，稍差一点，使用D3DImage优化后方案渲染，CPU占用并没有出现多大的跳跃，大约在30%左右。即使是添加了DropShadowEffect的情况下，CPU占用和内存占用好像都没有多大变化；既然在CPU和内存占用都没有多大变化的情况下，WPF渲染卡顿，那肯定（可能吧）是“帧生成”时间过长的锅。 帧生成时间玩游戏的人都知道，影响游戏帧数的一个关键因素是帧生成时间，帧生成时间过长必定导致游戏FPS下降，游戏不流畅。帧生成时间并不等同帧更新时间，这个需要搞清楚。例如一个游戏锁帧60FPS,那么帧更新时间为1000/60=16.6ms,通常来说，如果你硬件性能足够强劲，那么帧生成时间要小于16.6ms才能保证游戏运行在60FPS的帧率下，否则会掉帧。类似的，WPF的渲染帧率下降可能（无责任猜想）也是同样的因素导致。But why? DropShadowEffect 的锅不要误会，DropShadowEffect并没有什么过错。只是在特定情境下，DropShadowEffect（及其他所有Effect类），就是WPF渲染瓶颈的关键： 将Effect应用到时刻变化的元素 在应用了Effect的元素上，叠加了其他时刻变化的兄弟元素 … 远程会议的问题就是碰到了第二种情景，我们以为只要不直接应用DropShadowEffect到D3DImage这种时刻更新帧的元素上，应该就能避免渲染瓶颈，然而被打脸。说了这么久，好像还是没有说为什么；年轻人，不要这么着急，继续往下看。 WPF 的渲染知识两则 当WPF在渲染一个窗口的时候，它只更新需要更新的区域，称为脏区（DirtyRect）。 显存的占用与渲染面积成正相关 使用下面这个例子来模拟导致问题的场景：左边是应用了DropShadowEffect的Grid,中间是应用ColorAnimation的Grid,右边是3个视频渲染。暂时来说，情况看起来还是可以的，没有出现明显的渲染卡顿，整个界面的渲染都维持在一个比较高的帧数。那么，将中间的元素叠加在左边的元素上看看：问题出现了，帧率下降严重,视频出现卡顿，ColorAnimation变得不平滑：在这两种情况下，脏区数量都是一样的，分别是始终变化的ColorAnimation Grid和视频区，唯一不同的是，ColorAnimation Grid的位置变了，与应用了DropShadowEffect的Grid部分重叠了，这导致每帧渲染多了一个HW IRT(hardware intermediate render target)，对于WPF来说，HW IRT是一个代价高昂的渲染过程，比它更惨的是SW IRT,如果你的WPF程序在渲染过程中出现多个这种渲染过程，那么可以肯定你的程序需要完成大量的工作来渲染你的程序。 那么，什么是IRT?Intermediate Render Target。在现代的图形处理单元(GPU)中，我们可以将我们要进行渲染的内容先在Render Target中渲染，然后像素着色器可以通过处理这个Render Target来添加特定的效果，这个过程完成后才将处理完的数据储存到后台缓存（Back Buffer)，这个时候渲染线程（Render Thread)可以将back buffer拷贝到前台缓存（Front Buffer)进行显示。对应到上面的例子，动态元素在拥有DropShadowEffect的元素上刷新，引起脏区更新，这个脏区有关DropShadwoEffect，DropShadowEffect需要像素着色器渲染指令（因为它本身就是由HLSL创建的），嘣！！！，IRT就来了。但是，IRT在一次渲染中是很正常的啊，有些WPF程序在一次渲染中可能存在几个IRT都不会引起这么明显的性能下降。4K是性能的试金石，要知道，我们的程序是运行在4K下的，变化的脏区面积足够大，才引起了显著的性能下降，而且，不要忘了，WPF在使用像素着色器时有天生的缺陷，这篇文章有详细说明,其中提到的关键一点： WPF has an extensible pixel shader API, along with some build in effects. This allows developers to really add some very unique effects to their UI. In Direct3D when you apply a shader to an existing texture, it’s very typical to use an intermediate rendertarget…after all you can’t sample from a texture you are writing to! WPF does this also, but unfortunately it will create a totally new texture EACH FRAME and destroy it when it’s done. Creating and destroying GPU resources is one of the slowest things you can do on a per frame basis. I wouldn’t even typically do this with system memory allocations of that size. There would be a considerable performance increase on the use of shaders if somehow these intermediate surfaces can be reused. If you’ve ever wondered why you get noticeable CPU usage with these hardware accelerated shaders, this is why. 至此，WPF的渲染相关文章结束。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://gandalfliang.github.io/tags/WPF/"},{"name":"DirectX","slug":"DirectX","permalink":"https://gandalfliang.github.io/tags/DirectX/"},{"name":"渲染","slug":"渲染","permalink":"https://gandalfliang.github.io/tags/渲染/"},{"name":"Profiling","slug":"Profiling","permalink":"https://gandalfliang.github.io/tags/Profiling/"},{"name":"Perforator","slug":"Perforator","permalink":"https://gandalfliang.github.io/tags/Perforator/"}]},{"title":"D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践","slug":"D3DImageInDepth","date":"2017-09-11T04:19:30.000Z","updated":"2019-01-10T12:18:47.821Z","comments":true,"path":"2017/09/11/D3DImageInDepth/","link":"","permalink":"https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/","excerpt":"D3dImage，.Net Framework 3.5 之后，微软提供的一个全新的ImageSource对象，可以在WPF中很好的呈现DirectX内容；在此之前，你只能将DirectX内容直接渲染在Windows窗口之上，这必然引起令人头疼的AirSpace问题，为了在这些内容上面添加我们习以为常的WPF UI 元素，你只能使用Popup来承载这些内容，完全丧失WPF UI开发的灵活性，且有经验的WPF程序员都知道一个事实：WPF Popup就是一个深坑 - 你需要手动处理各种显示隐藏问题、因为其导致的焦点问题，显示层级问题以及最令人头疼的性能问题，特别是在4K屏幕下，因为我们都知道，Popup就是一个Window，为了解决Airspace问题而使用Popup来承载UI必定需要使其AllowTransparency=True，这就引起了另外一个问题，透明窗口占用内存与其面积成正相关，在4K屏幕下，你可能将整个程序大部分的内存占用贡献给了这些Popup UI。说了这么多，好像在诉控Popup有多么的垃圾（它的确如此，如果在做大量的UI容器时）。 年轻人，如果你觉得Airspace问题真的没有办法解决了，只能用Popup这种技术手段来规避了，那么听老人一句话，不要浪费时间在Popup上了，因为你在前期投入的时间来规避种种Popup UI导致的问题以及各种你意想不到的Bug，到最后总会碰到解决不了，完全不能规避的情况，从而导致整个Popup UI替换方案完全失败的情形。","text":"D3dImage，.Net Framework 3.5 之后，微软提供的一个全新的ImageSource对象，可以在WPF中很好的呈现DirectX内容；在此之前，你只能将DirectX内容直接渲染在Windows窗口之上，这必然引起令人头疼的AirSpace问题，为了在这些内容上面添加我们习以为常的WPF UI 元素，你只能使用Popup来承载这些内容，完全丧失WPF UI开发的灵活性，且有经验的WPF程序员都知道一个事实：WPF Popup就是一个深坑 - 你需要手动处理各种显示隐藏问题、因为其导致的焦点问题，显示层级问题以及最令人头疼的性能问题，特别是在4K屏幕下，因为我们都知道，Popup就是一个Window，为了解决Airspace问题而使用Popup来承载UI必定需要使其AllowTransparency=True，这就引起了另外一个问题，透明窗口占用内存与其面积成正相关，在4K屏幕下，你可能将整个程序大部分的内存占用贡献给了这些Popup UI。说了这么多，好像在诉控Popup有多么的垃圾（它的确如此，如果在做大量的UI容器时）。 年轻人，如果你觉得Airspace问题真的没有办法解决了，只能用Popup这种技术手段来规避了，那么听老人一句话，不要浪费时间在Popup上了，因为你在前期投入的时间来规避种种Popup UI导致的问题以及各种你意想不到的Bug，到最后总会碰到解决不了，完全不能规避的情况，从而导致整个Popup UI替换方案完全失败的情形。 什么是AirSpace问题这是一个很复杂的问题，涉及到整个WPF的渲染机制，简单的来说，就是对于WPF窗口的子窗口，其并不是由父窗口负责渲染的，而是由其自己负责自己的渲染，子窗口不能像其他元素一样由父元素来进行布局、渲染（这很好理解），因此，如果我们要在一个WPF窗口中承载另外一个子窗口，那么其渲染并不受父窗口控制，它会渲染在父窗口所有元素之上，这就是导致上面提到的需要用Popup UI来规避Airspace问题的原因。那么问题来了，我为什么要在一个窗口里面渲染另外一个窗口？这不科学。这的确是一个不科学的操作，因为没人会这样做，除非你需要和DirectX内容打交道，特别是对于在WPF做多媒体应用开发的程序员，WPF和DirectX内容的交互 是一个不可避免的问题（虽然我觉得用WPF做多媒体应用本身就存在问题，但这不在本篇文章讨论的范围）。不仅是DirectX内容，在WPF中承载WinForm控件也有同样的问题，为了解决这种问题，微软曾在.Net Framework 4.5的某个预览版（如果没记错的话）中提供了对应的解决方案，但是在正式版中并没有保留，很可惜。 WPF多媒体程序开发的好帮手 - D3DImageD3DImage就是一个全新的ImageSource，你可以完全根据你对ImageSource的理解来使用它D3DImage。为什么说它是WPF多媒体程序的好帮手？正如我上面提到的，我不觉得WPF是多媒体应用开发的第一选择，多媒体应用是一种性能敏感的程序类型，先不说使用WPF你很难触碰到底层的渲染机制，进行调优；而且，你不能原生访问Direct3D接口，即使，至少对于Windows平台下，多媒体内容大多都使用Direct3D API来进行渲染、绘制（更不用说OpenGL了，其对于WPF来说几乎就是一个不可能的选项）。因此我们需要D3DImage，其为你在WPF中使用Direct3D接口和内容提供了一种可能，尽管那是一种不那么直观的方式。说到底，我们需要解决的问题是将Direct3D原生渲染的内容，以一种WPF熟悉的，原生的方式渲染在WPF上。在D3DImage之前，你只能直接渲染在窗口上，因为窗口是Direct3D渲染设备的必须参数。而D3DImage，不要误会，它并不是可以让Direct3D不用窗口进行渲染，而是为Direct3D渲染的内容提供了一个“通道”，这个”通道”使WPF可以将ID3DDevice上的渲染表面ID3DSurface更新到其渲染线程中（这种说法并不准确，但是你可以先这样理解，至于它们是怎样”共享“表面的，我们以后再谈）。 一切看起来都是那么完美，但是…可以想象的到，D3DImage方式并不能提供比肩原生渲染的性能，不论是CPU占用还是内存占用。特别是当你需要兼顾Windows XP的时候，那性能就更加难看了。WPF虽然说是支持硬件加速的一个框架，但是它有原生缺陷，这篇文章描述了一些深入的问题。要知道，在Windows Vista之前，即Windows Xp，只能使用D3D9接口创建D3dDevice，我们甚至不能使用D3D9Ex接口，对于D3DImage来说，这是一个很大的性能损耗，因为由D3D9接口创建的D3dSurface与WPF的D3Dimage渲染过程中存在一个很恶心的过程，WPF需要将显存中的D3DSurface内容拷贝回系统内存，处理完后再拷贝回显存进行渲染，毫无疑问会导致CPU占用和内存占用上升。我们使用剪辑师来做一个实验，在关闭硬件加速的情况下，对比使用两种接口来创建渲染表面的性能表现：在关闭硬件加速的情况下，使用剪辑师播放一个2K分辨率的视频在不同时刻的CPU占用： 可以看出存在明显的性能差别，在使用D3DEx接口创建渲染表面进行和WPF的交互操作时，并不存在上面提到的显存→系统内存拷贝问题，其直接在显存中进行拷贝，这样会降低CPU损耗。即使这样，它也不能提供比原生窗口渲染更好的性能，这在我们意料之内。 最佳实践 不要支持Windows XP 使用D3D9Ex以上接口来创建你要在D3DImage承载的Direct3D内容 不要在UI上使用DropShadowEffect，一点都不可以关于这一点，又是一个可以深究的问题，但是这里就先简单的说一下。在远程会议的开发中，我们在渲染8分屏的时候，发现使用D3DImage进行视频渲染的时候，性能表现远远低于原生窗口渲染的方式，虽然知道D3DImage性能上与原生渲染存在差距，但是也不可能相差这么远。刚开始的时候我并没有怀疑DropShadowEffect，因为我知道它会带来性能问题，因此我还故意将其应用到一个空的Grid上，而不是直接应用到D3DImage上，而且这个Grid和Image并不是父子关系，在我的印象中，这样可以规避将整个D3DImage的像素数据进行DropShadowEffect的管道数据处理（DropShadowEffect本质是一个像素着色器，像素着色器是一个高性能组件，对于现代3D游戏来说，是一个必不可少的组件，但是这篇文章已经提到，WPF里的像素着色器并不完全是那么一回事），按理说，性能瓶颈并不应该出现在这里，然而，它的确是这里，原因是啥？我也不清楚，或许以后有结论之后我们再开一篇文章来谈谈。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"D3DImage","slug":"D3DImage","permalink":"https://gandalfliang.github.io/tags/D3DImage/"},{"name":"WPF","slug":"WPF","permalink":"https://gandalfliang.github.io/tags/WPF/"},{"name":"DirectX","slug":"DirectX","permalink":"https://gandalfliang.github.io/tags/DirectX/"}]},{"title":"FFmpeg 入门","slug":"FFmpegCookbook_1","date":"2017-08-18T04:19:30.000Z","updated":"2018-02-12T07:23:32.961Z","comments":true,"path":"2017/08/18/FFmpegCookbook_1/","link":"","permalink":"https://gandalfliang.github.io/2017/08/18/FFmpegCookbook_1/","excerpt":"","text":"废话少说，要解码一个视频帧，你需要这样做： 获得帧数据后，用SDL还是直接用D3d渲染，那就看你自己了。st=>start: Start e=>end: End o=>operation: 初始化 av_register_all; avformat_network_init; o1=>operation: 打开文件: avformat_open_input; o2=>operation: 获取stream并打开符合的codec : avformat_find_stream_info; avcodec_find_decoder; avcodec_open2; o3=>operation: av_read_frame; avcodec_decode_video2; st->o->o1->o2->o3->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12,\"line-height\":30} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://gandalfliang.github.io/tags/FFmpeg/"},{"name":"音视频","slug":"音视频","permalink":"https://gandalfliang.github.io/tags/音视频/"},{"name":"解码","slug":"解码","permalink":"https://gandalfliang.github.io/tags/解码/"}]},{"title":"D3DImage in WPF","slug":"D3DImageInWPF","date":"2017-06-11T15:10:50.000Z","updated":"2018-02-12T07:23:29.192Z","comments":true,"path":"2017/06/11/D3DImageInWPF/","link":"","permalink":"https://gandalfliang.github.io/2017/06/11/D3DImageInWPF/","excerpt":"","text":"在.Net Framework 3.5 SP1中，微软在WPF中提供了D3DImage对象，D3DImage是一个ImageSource，这可以让我们在WPF原生的D3D Surface上渲染Direct3D Surface，大大提高了WPF和DirectX内容的交互性。在此之前，要想在WPF上渲染DirectX的内容，只能让DirectX直接渲染到窗口上，这样会造成不可避免的Airspace问题，因为DirectX内容要时刻刷新重绘，导致WPF窗口上的其他内容被覆盖，表现就是DirectX内容始终在窗口最顶层。正如前面所说，D3DImage是一个ImageSource，在WPF中，这意味着，我们可以将一个3D场景变成一个Image对象的Source，或者构建一个ImageBrush，这意味这D3D Surface可以渲染到WPF中任意一个以Brush进行渲染的元素上，例如图片，文本前景色，元素背景色等等。如下，就是一个典型的应用D3DImage的代码：1234567891011121314if (d3dimg.IsFrontBufferAvailable)&#123; IntPtr pSurface = IntPtr.Zero; pSurface = _view.GetBackBuffer(); if (pSurface != IntPtr.Zero) &#123; d3dimg.Lock(); d3dimg.SetBackBuffer(D3DResourceType.IDirect3DSurface9,pSurface); _view.Draw(); d3dimg.AddDirtyRect(new Int32Rect(0, 0, d3dimg.PixelWidth, d3dimg.PixelHeight)); d3dimg.Unlock(); &#125;&#125; 只需要Direct3D内容渲染的Surface接口指针即可，如上面的pSurface。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"D3DImage","slug":"D3DImage","permalink":"https://gandalfliang.github.io/tags/D3DImage/"},{"name":"WPF","slug":"WPF","permalink":"https://gandalfliang.github.io/tags/WPF/"},{"name":"DirectX","slug":"DirectX","permalink":"https://gandalfliang.github.io/tags/DirectX/"}]},{"title":"【翻译】There Is No Thread","slug":"ThereIsNoThread","date":"2017-05-02T10:14:58.000Z","updated":"2018-02-12T07:24:05.690Z","comments":true,"path":"2017/05/02/ThereIsNoThread/","link":"","permalink":"https://gandalfliang.github.io/2017/05/02/ThereIsNoThread/","excerpt":"","text":"这里并没有线程原文地址： http://blog.stephencleary.com/2013/11/there-is-no-thread.html 最纯粹的async形式中存在一个重要的真相：这里并没有线程（或者不存在新建的线程）举不胜数的反对者哭喊道：“不！如果我正在等待一个操作，那一定存在一个线程在等待这个操作！它可能是一个线程池中的线程。或者是系统线程！或者是其他类似设备驱动的东西…”。 不要听从那些哭喊的人。如果那些async操作是纯粹的，那么这里将不会存在线程。 那些持怀疑态度的人并没有被说服。让我们来娱乐一下他们。 我们可以一路跟踪一条异步操作指令到硬件层面，特别留意其中的.Net部分和设备驱动部分。为了简化这部分描述，我们排除掉部分中间层的细节，但是这应该不会让我们偏离真相。 思考一个通用的“写”操作（写一个文件、网络流、USB等等）。我们的代码很简单： 12345private async void Button_Clicked(object sender, RoutedEventArgs e)&#123; byte[] data = ... await myDevice.WriteAsync(data, 0, data.Length);&#125; 我们早就知道，UI线程并不会被await操作阻塞。那么问题来了：这里是不是存在另外一个线程，它牺牲自己所以UI线程才能存活？ 抓住我的手，我们要潜的更深一点。 第一站：类库（例如，查看BCL代码）。我们假设 WriteAsync 是用 .Net 标准的 P/Invoke 异步 I/O 操作实现的。所以，这个操作在设备的句柄上开始了一个Win32的重叠I/O操作。 系统紧接着转到设备驱动并让设备开始写操作。它首先构造一个表示写请求的对象，这被称为I/O Request Packet(IRP)。设备驱动获得这个IRP并向设备发起命令来写对应的数据。如果设备支持Direct Memory Access(DMA)，这个操作就像向设备寄存器中写入缓存地址一样简单。这是设备驱动能做的所有事情；它使得IRP进入“等待”并转回到系统。 事实的核心：当处理IRP时，设备驱动不允许堵塞。这意味着，如果IRP不能立即完成，那么它一定要异步执行。这对于同步API也一样成立。在设备驱动这一层，所有（重要的）请求都是异步的。随着IRP进入“等待”状态，系统通过返回一个未完成的Task给刚才堵塞的async按钮点击事件，然后UI线程继续执行。我们深入追踪到系统底层的写操作，直至物理设备。现在，写操作正在执行，那有多少线程在处理它呢？ 一个都没有这里并没有设备驱动线程，系统线程，BLC线程或者线程池线程在处理那个写操作。这里根本就没有线程现在，我们看一下对应的回复（Response)。写请求开始片刻，设备完成了写操作，他通过中断（Interrupt)通知CPU。设备驱动的Interrupt Service Routine(ISR)对这个中断做出反应。中断是CPU层的时间，它会临时从当前CPU所运行的线程中获得CPU的控制权。你可以认为ISR是在“借用”当前正在运行的线程，但是我更倾向于认为ISR在更底层中执行，底层到根本不存在线程这个概念的水平。或者说它在所有线程之下。无论如何，ISR已经被妥当的进行了写操作，它做的所有事情就是告诉设备“谢谢你的中断请求”并且将一个Deferred Procedure Call(DPC)入队（queue)。当CPU被中断“骚扰”完之后，它会转向它的DPC。DPC也是在一个不能直接用线程描述的底层水平。和ISR一样，DPC直接在CPU上执行，在线程系统之下。DPC获取代表写操作的ISR并将其标志成“完成”。然而，那么“完成”状态只存在系统层；必须要通知到进程自己拥有的内存空间。所以系统会入队一个special-kernel-mode Asynchronous Procedure Call(APC)给拥有HANDLE的线程。因为上述提到的类库/BLC使用的是标准P/Inovke Overlapped I/O 系统，它早就注册了I/O Completion Port(IOCP)的句柄，这个句柄是线程池的一部分。所以，一个I/O线程池线程被短暂的“借用”来执行APC,通过它来通知task已经完成。现在task捕获了UI线程的上下文，它不直接从线程池线程中返回async方法，相反，它将async方法后续的执行加入到UI线程的上下文，当UI线程执行到这里的时候就会继续执行这部分代码。所以，当请求发生时，我们可以看到这里并没有线程。当请求完成时，大量的线程被“借用”或者短暂暂存到它们那里。这些工作大约在一毫秒（运行在线程池的APC)或者低到一微秒（例如ISR)。但是这里并没有线程因为等待请求完毕而被堵塞。","categories":[{"name":"翻译","slug":"翻译","permalink":"https://gandalfliang.github.io/categories/翻译/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://gandalfliang.github.io/tags/翻译/"},{"name":"async/await","slug":"async-await","permalink":"https://gandalfliang.github.io/tags/async-await/"}]},{"title":"Mandelbrot Set - 在复平面上绘制曼德博集合","slug":"Mandelbrot","date":"2017-03-19T05:58:27.000Z","updated":"2019-01-10T12:20:07.941Z","comments":true,"path":"2017/03/19/Mandelbrot/","link":"","permalink":"https://gandalfliang.github.io/2017/03/19/Mandelbrot/","excerpt":"","text":"曼德博集合（Mandelbrot set，或译为曼德布洛特复数集合）是一种在复平面上组成分形的点的集合，以数学家本华·曼德博的名字命名。曼德博集合与朱利亚集合有些相似的地方，例如使用相同的复二次多项式来进行迭代。(维基百科) 其中的迭代公式：1f(Zn+1)=Zn^2+c 其中，c是任意复数。我们知道c可以表示为：c=x+y*i。根据复数的定义，i^2=-1。因此，我们通过将二维平面当作复平面，x是其中复数的实部R,y是复数的虚部Im。根据上面的额迭代公式，使用OpenCL对每个点进行同步的迭代，快速得到曼德博集合。 12345678910111213141516171819202122232425262728293031323334353637383940414243//openCL代码kernel void Mandelbrot( global write_only int* result, int width,//图片宽度 int height,//图片高度 float minReal,//最小实部 float maxReal,//最大实部 float minIma,//最小虚部 float maxIma,//最大虚部 int max_iter)//最大迭代次数，当迭代这么多次后，该复数还没逃逸，则认为其在曼德博集合中&#123; //获取GPU当前线程的编号，可以将这个物化为图片当前位置的一个像素点的计算方位 int tX = global_get_id(0); int tY = global_get_id(1); //计算坐标的刻度值 float real_inter = (maxReal - minReal) / width; float ima_inter = (maxIma - minIma) / height; //当前线程（像素点）在复平面的位置 int cX = minReal + tx * real_inter; int cY = minIma + (height - tY) * ima_inter; //迭代 float zX=0; float zY=0; int iter=0; float length_sqr=0; do &#123; iter++; float temp = zX * zX - zY * zY + cX; zY = 2 * zX * zY + cY; zX = temp; length_sqr=zX * zX + zY * zY;//在GPU上，根号运算要慢得多 &#125;//根据曼德博集合的性质，我们知道集合的中的任意一个复数|z|&lt;2,因此对于复数z=tX+tY*i,|z|^2=tX*tX+tY*tY&lt;4 while(length_sqr &lt; 4 &amp;&amp; iter &lt; max_iter); int loc = tY * width + tX; result[loc] = iter;//通过迭代值来标识当前位置的像素点是否属于曼德博集合&#125; 这种每个点都可以独立迭代运算，互不干扰的特性，最适合用GPU来进行计算的了，因此，通过OpenCL,我们可以快速得到想要的数据。使用 Surface Book 的内置显卡nVidia 520计算3000*3000规模,迭代512次的数据，可以在30ms内完成。如下是通过得到的数据生成的一些配色图： 复数与曼德罗集合的相关信息，可参考：https://msdn.microsoft.com/zh-cn/library/jj635753(v=vs.85).aspx","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"曼德博集合","slug":"曼德博集合","permalink":"https://gandalfliang.github.io/tags/曼德博集合/"},{"name":"OpenCL","slug":"OpenCL","permalink":"https://gandalfliang.github.io/tags/OpenCL/"},{"name":"高性能计算","slug":"高性能计算","permalink":"https://gandalfliang.github.io/tags/高性能计算/"}]},{"title":"OpenCL with CLOO","slug":"OpenCLwithCLOO","date":"2017-03-11T13:19:30.000Z","updated":"2018-02-12T07:23:59.095Z","comments":true,"path":"2017/03/11/OpenCLwithCLOO/","link":"","permalink":"https://gandalfliang.github.io/2017/03/11/OpenCLwithCLOO/","excerpt":"CLOO 是一个对 OpenCL 的 .Net 封装，可以让 .Net/Mono 程序充分使用 OpenCL 的优势，易用、开源。 今天用 OpenCL 中的 “Hello World” 程序 - 矩阵乘法，来简单介绍一下 OpenCL。 OpenCL 是一个开放的工业标准，既然是开放的，那么，所有厂商就可以提供自己的实现，例如英特尔，英伟达等等。也正因为如此，也导致在同一台机器上可能存在多个支持不同版本的硬件。例如，英伟达的GPU到现在也才支持 OpenCL 1.2 版本，但是OpenCL都已经出到2.x版本了。 我们可以查看当前设备中，有哪些厂商提供了 OpenCL 的支持，以及运算平台是啥。例如，在 Surface Book (with Nvidia GPU) 上，我们调用以下代码看看： 1234567891011121314//获取所有平台var platforms = ComputePlatform.Platforms;foreach(var platform in platforms)&#123; Console.WriteLine($\"&#123;platform.Name&#125;,&#123;platform.Version&#125;\"); //获取该平台下的计算设备 var devices = platform.QueryDevices(); foreach(var device in devices) &#123; Console.WriteLine($\" Device:&#123;device.Name&#125;\"); &#125;&#125;","text":"CLOO 是一个对 OpenCL 的 .Net 封装，可以让 .Net/Mono 程序充分使用 OpenCL 的优势，易用、开源。 今天用 OpenCL 中的 “Hello World” 程序 - 矩阵乘法，来简单介绍一下 OpenCL。 OpenCL 是一个开放的工业标准，既然是开放的，那么，所有厂商就可以提供自己的实现，例如英特尔，英伟达等等。也正因为如此，也导致在同一台机器上可能存在多个支持不同版本的硬件。例如，英伟达的GPU到现在也才支持 OpenCL 1.2 版本，但是OpenCL都已经出到2.x版本了。 我们可以查看当前设备中，有哪些厂商提供了 OpenCL 的支持，以及运算平台是啥。例如，在 Surface Book (with Nvidia GPU) 上，我们调用以下代码看看： 1234567891011121314//获取所有平台var platforms = ComputePlatform.Platforms;foreach(var platform in platforms)&#123; Console.WriteLine($\"&#123;platform.Name&#125;,&#123;platform.Version&#125;\"); //获取该平台下的计算设备 var devices = platform.QueryDevices(); foreach(var device in devices) &#123; Console.WriteLine($\" Device:&#123;device.Name&#125;\"); &#125;&#125; 输出： 123456Intel(R) OpenCL, OpenCL 2.0 Device:Intel(R) HD Graphics 520 Device:Intel(R) Core(TM) i7-6600U CPU @ 2.60GHzNVIDIA CUDA, OpenCL 1.2 CUDA 8.0.0 Device:GeForce GPU 可以看出这台机器上有两个支持 OpenCL 的平台，英特尔的CPU和英伟达的GPU，其中，INTEL CPU 里又有两个计算设备 CPU 和集成的核显 HD520。毫无疑问，在 OpenCL 上，英伟达的GPU可以提供比 Intel CPU 高得多的性能，毕竟，GPU的流处理器数量要比CPU上那可怜的核显上的要多得多。 主机代码(host)和核心代码(kernel)OpenCL分有主机代码和核心代码，相对于核心代码，主机代码用于对环境进行初始化，例如配置运行平台，计算设备等的。而核心代码，就是运行在指定计算设备的代码，例如GPU。这就好像DirectX上的HLSL一样，HLSL的代码只运行在GPU上。 OpenCL是一个动态编译的框架，就是说核心代码是在运行时才被编译的，程序运行时，在核心代码还没被编译前我们都可以更改核心代码。 矩阵乘法矩阵乘法，以最普通的算法来进行计算，是时间复杂度为O(n^3)的算法，时间都花在做重复的加法和乘法运算，这种情景最适合用GPU来进行处理了。先来看一下常规的算法：1234567891011//假设为两个规模为Rank的方形矩阵int matrixA[Rank][Rank];int sum[Rank][Rank];void Mul()&#123; for (int i = 0; i &lt; Rank; i++) for (int j = 0; j &lt; Rank; j++) for (int k = 0; k &lt; Rank; k++) sum[i][j] += matrixA[i][k] * matrixA[k][j];&#125; 分析： 我们要让这段代码在GPU上快速运行，当然，我们不能直接就让这段代码作为我们的OpenCL核心代码，因为这样并不能发挥GPU同步计算的优势。我们让想办法将整个流程拆分为各个可以同时进行的子运算，让GPU同步并行计算，以此降低计算耗时。 如下，是这个程序的OpenCL核心代码：1234567891011121314151617kernel void MatrixMul( global write_only int* result, global read_only int* matrix, int rank)&#123; int gx=get_global_id(0); int gy=get_global_id(1); int loc=gx*rank+gy; for(int i=0;i&lt;rank;i++) &#123; int leftLoc=gx*rank+i; int rightLoc=i*rank+gy; result[loc]+=matrix[leftLoc]*matrix[rightLoc]; &#125;&#125; 这就是实际上跑在GPU上的代码。前面提到，OpenCL是动态编译的框架，这段代码你可以放在任何一个文本文件中，但是有一个注意的是，只有kernel标志的函数才是程序入口。 而下面的就是主机代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495using System;using System.IO;using System.Linq;using System.Runtime.InteropServices;using Cloo;using System.Diagnostics;namespace MatrixDemo&#123; class Program &#123; static void Main(string[] args) &#123; Matrix_mul_opencl(500); Matrix_mul_opencl(1000); Matrix_mul_opencl(1500); &#125; static void Matrix_mul_opencl(int r) &#123; //选取设备 var platform = ComputePlatform.Platforms.FirstOrDefault(); var device = platform.Devices.FirstOrDefault(); //设置相关上下文 var properties = new ComputeContextPropertyList(platform); var context = new ComputeContext(new[] &#123; device &#125;, properties, null, IntPtr.Zero); //命令队列，用于控制执行的代码 ComputeCommandQueue commands = new ComputeCommandQueue(context, context.Devices[0], ComputeCommandQueueFlags.None); //读取opencl代码 var code = File.ReadAllText(\"matrix.cl\"); //编译 var program = new ComputeProgram(context, code); try &#123; program.Build(null, null, null, IntPtr.Zero); &#125; catch (Exception ex) &#123; throw; &#125; //创建核心代码，就是cl代码中以kernel标识，函数签名为MatrixMul的函数 var kernel = program.CreateKernel(\"MatrixMul\"); //矩阵规模 int rank = r; //储存计算结果的数组 var result = new ComputeBuffer&lt;int&gt;(context, ComputeMemoryFlags.WriteOnly, rank * rank); var matrix = CreateMatrix(context, rank); //创建的核心代码函数以这种方式来传参 kernel.SetMemoryArgument(0, result); kernel.SetMemoryArgument(1, matrix); kernel.SetValueArgument(2, rank); Console.WriteLine($\"运行平台: &#123;platform.Name&#125;\\n运行设备： &#123;device.Name&#125;\\n矩阵规模: &#123;rank&#125;x&#123;rank&#125;\"); Stopwatch sw = Stopwatch.StartNew(); //执行代码 commands.Execute(kernel, null, new long[] &#123; rank, rank &#125;, null, null); int[] resultArray = new int[rank * rank]; var arrHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned); //读取数据 commands.Read(result, true, 0, rank * rank, arrHandle.AddrOfPinnedObject(), null); var elapsed = sw.Elapsed; Console.WriteLine($\"耗时: &#123;elapsed.TotalMilliseconds&#125; ms\\n\"); arrHandle.Free(); kernel.Dispose(); &#125; //创建实验矩阵 static ComputeBuffer&lt;int&gt; CreateMatrix(ComputeContext context, int rank) &#123; int size = rank * rank; int[] datas = new int[size]; for (int i = 0; i &lt; size; i++) &#123; datas[i] = i % 10; &#125; var matrix = new ComputeBuffer&lt;int&gt;(context, ComputeMemoryFlags.CopyHostPointer, datas); return matrix; &#125; &#125;&#125; 输出：1234567891011121314运行平台: NVIDIA CUDA运行设备： GeForce GTX 1060 6GB矩阵规模: 500x500耗时: 28.7764 ms运行平台: NVIDIA CUDA运行设备： GeForce GTX 1060 6GB矩阵规模: 1000x1000耗时: 224.5405 ms运行平台: NVIDIA CUDA运行设备： GeForce GTX 1060 6GB矩阵规模: 1500x1500耗时: 1024.3869 ms 对于矩阵规模为500x500的计算，耗时28毫秒，1500的规模则需要1024毫秒，这性能，比用常规方法跑在CPU上，耗时要18秒的情况不知道高到哪里去了。但是有个诡异的事情是，在Windows 10上，当我尝试将矩阵规模提升到2000或以上时，opencl会抛出OutOfResource异常，但是相同规模的矩阵乘法运算，用C++ AMP计算跑在相同的设备上却没有问题，恩，或许这个跟英伟达的显卡驱动或者Windows 10的内存机制有关，有空再讲。 那还有没有更快的方法呢？当然有了，我们下篇文章再谈。","categories":[{"name":"技术","slug":"技术","permalink":"https://gandalfliang.github.io/categories/技术/"}],"tags":[{"name":"OpenCL","slug":"OpenCL","permalink":"https://gandalfliang.github.io/tags/OpenCL/"},{"name":"CLOO","slug":"CLOO","permalink":"https://gandalfliang.github.io/tags/CLOO/"},{"name":"通用计算","slug":"通用计算","permalink":"https://gandalfliang.github.io/tags/通用计算/"}]},{"title":"深挖 WPF 渲染系统","slug":"ACriticalDeepDiveIntoTheWPFRenderingSystem","date":"2017-03-03T07:30:30.000Z","updated":"2018-08-25T03:27:42.010Z","comments":true,"path":"2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/","link":"","permalink":"https://gandalfliang.github.io/2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/","excerpt":"这是一篇2011年的文章，原地址在 A Critical Deep Dive into the WPF Rendering System，个人认为到现在都可以给WPF程序开发人员作为一个参考，里面详细讲述了 WPF 这个号称从底层支持硬件加速的 UI 框架为什么有时候看起来并不是那么回事的原因。以下是正文。 刚开始我并不认为我会发表这篇文章。在被一些我高度重视的人说服后，我决定要发表这篇文章。那些深入投入微软UX平台的程序员应该更加深入了解这个平台内部是怎么工作的，当他们撞到一睹石墙的时候，他们可以清晰了解到问题所在并且更加准确地沟通他们希望平台做出怎样的改变。 我相信 WPF 和 Silverlight 是精心打造的技术，但是…如果这几个月你有关注我的Twitter，你也许会发现我一直在吐槽WPF（Silverlight也一样）的性能。为什么我会这样做？毕竟这些年我花费了大量的时间为这个平台布道、写库、社区帮助和指导等等。准确来讲，我个人全身投入到这个平台里面，我希望这个平台越来越好。 性能，性能，性能当在开发沉浸式的、消费者导向的UX的时候，性能是你第一位的特性。性能是你添加其他特性的前提和基础。有多少次因为UI太卡你需要缩小UI的规模？有多少次因为这个技术做不到所以你需要丢弃“开创性的UX模型”？有多少次你告诉客户他们需要一个2.4GHz的四核CPU才能获得全部的体验？我一直以来都被客户问，为什么在PC上拥有4倍于iPad的性能的情况下，WPF程序却做不到像iPad应用那般流畅？","text":"这是一篇2011年的文章，原地址在 A Critical Deep Dive into the WPF Rendering System，个人认为到现在都可以给WPF程序开发人员作为一个参考，里面详细讲述了 WPF 这个号称从底层支持硬件加速的 UI 框架为什么有时候看起来并不是那么回事的原因。以下是正文。 刚开始我并不认为我会发表这篇文章。在被一些我高度重视的人说服后，我决定要发表这篇文章。那些深入投入微软UX平台的程序员应该更加深入了解这个平台内部是怎么工作的，当他们撞到一睹石墙的时候，他们可以清晰了解到问题所在并且更加准确地沟通他们希望平台做出怎样的改变。 我相信 WPF 和 Silverlight 是精心打造的技术，但是…如果这几个月你有关注我的Twitter，你也许会发现我一直在吐槽WPF（Silverlight也一样）的性能。为什么我会这样做？毕竟这些年我花费了大量的时间为这个平台布道、写库、社区帮助和指导等等。准确来讲，我个人全身投入到这个平台里面，我希望这个平台越来越好。 性能，性能，性能当在开发沉浸式的、消费者导向的UX的时候，性能是你第一位的特性。性能是你添加其他特性的前提和基础。有多少次因为UI太卡你需要缩小UI的规模？有多少次因为这个技术做不到所以你需要丢弃“开创性的UX模型”？有多少次你告诉客户他们需要一个2.4GHz的四核CPU才能获得全部的体验？我一直以来都被客户问，为什么在PC上拥有4倍于iPad的性能的情况下，WPF程序却做不到像iPad应用那般流畅？ 我觉得 WPF 是有应用硬件加速技术的？告诉我为什么你觉得它效率低。WPF是有硬件加速的，并且其内部工作的某些部分也是很简洁的。不幸的是，它并没有像它应该能够做的的那样来高效率地使用GPU。它的渲染系统是非常暴力的。我希望在这里解释我为什么这样说。 分析一个完整的 WPF 渲染流程为了分析性能，我们需要知道WPF底层到底在干什么。要做到这个，我使用“PIX”工具，这是DirectX SDK里的一个Direct3D性能分析工具。PIX会加载基于D3D的程序并向所有的Direct3D调用注入钩子来分析和监控程序。 我创建了一个简单的WPF程序，里面从左到右有两个圆形。每个圆形有相同的填充色（#55F4F4F5)和一个黑色的描边。如下图： WPF 程序是怎样渲染这个程序的？WPF做的第一件事情是清理出一块需要重新绘制的废弃区域。废弃区域的作用是减少发送给GPU管道中输出合并阶段的像素量。我们甚至可以猜测，这样可以减少需要重新进行曲面细分的多边形数量（稍后会提到）。废弃区域清理后我们的帧看起来像这样： 接着，WPF做了某些我不能理解的事情。它首先填充了一个顶点缓存区，然后这就好像在废弃区域上绘制了一个四边形。所以现在的帧看起来是这样的（兴奋吧？）： 下一步，它在CPU上对一个圆形进行曲面细分。曲面细分，你或许已经听过，但是重要的是它将我们100X100的圆形多边形变成了一堆三角形。会这样的原因是1）三角形是GPU渲染的基本单位。2）对一个圆形进行曲面细分可能只是几百个顶点，所有它比在CPU上对10000个反锯齿的像素进行栅格化（Silverlight就是如此）要快得多。下图是这次曲面细分看起来的样子。对于熟悉3D编程的人来说，你们或许已经注意到这是一个三角形条带。注意，在曲面细分中圆形看起来并不完整。WPF然后将这次曲面细分的结果加载到GPU顶点缓存区，并根据在xaml中定义的画笔颜色，使用像素着色器来发起另外一个绘制命令。 还记得我提到这个圆形看起来是不完整的吗？事实上它的确是。WPF然后生成一种Direct3D程序员知道的“线序列”。GPU像理解三角形一样理解直线。WPF将这些线条填充到一个顶点缓存区中…然后你可以猜到！又发起另外一个绘制调用。这是这些线条集合看起来的样子： 所以，WPF已经完成了对圆形的绘制，对吧？并没有！你忘了它还有一条外描边！外描边同样是一个线条集合。这个集合会被发送到GPU的顶点缓存区并且另外一条绘制命令也会被调用。这是描边看起来的样子： 到目前为止我们完成了一个圆形的绘制，我们的帧看起来是这样的： 这个流程在这个场景下要为每个圆形进行一次。在这里是两个。 我就不明白了，为什么这样对性能有害？你应该注意到的第一件事情是为了绘制一个圆形它需要调用3次绘制。在这3次绘制调用中，相同的顶点缓存区被使用了两次。为了解释为什么这是低效率的，我需要稍微解释一些GPU是怎样工作的。首先，今日的GPU以非常快的速度处理数据并且异步地和CPU一起运行。并且，在确定的操作中存在耗时的用户态到核心态的切换。在这个例子里，在填充顶点缓存区时一定要锁定它。如果当前GPU正在使用缓存区，这样会导致GPU与CPU同步，引起性能瓶颈。顶点缓存区是通过 D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC创建的，但是当它被锁定时（事实上经常发生），D3DLOCK_DISCARD 并没有被使用。如果缓存区正在被GPU使用可能会导致GPU“失速”（CPU与GPU同步）。在存在很多绘制调用的例子中，我们可能有大量的内核过渡和驱动负载。高性能的目标是发送尽量多的工作给GPU，否则你的CPU会忙的要死而GPU却非常空闲。同样，不要忘了在这个例子中我只谈到一帧。典型的WPF UI会尝试在每秒里处理60帧！如果你曾怀疑过那些渲染线程的高CPU占用是从哪里来的，你会发现许多（大部分）是来自GPU驱动。 那Cached Composition呢？这真的能提升性能毫无疑问的确如此。Cached Composition，也就是BitmapCache，通过缓存GPU贴图的图像来工作。这意味着你的CPU不用重新对图像进行曲面细分，GPU也不用重新栅格化。在一次渲染当中，WPF通过使用显存中的贴图来进行渲染以提高性能。下图是一个圆形的BitmapCache: WPF在这方面也是存在缺陷的。对于每一个它遇到的BitmapCache，它发起一次绘制调用。公平来讲，有时候在某些情况下为了渲染图像你必须发起一次渲染调用。这是自然而然的。但是我们举一个例子：在一个Canvas里面填充300个BitmapCache圆形。一个高级系统会知道它有300个依层次排列的圆形。然后像DX9一次处理16个采样输入那样，尽量多地批量处理这些圆形。在这个例子中，可以将300次绘制调用降低到19次并节省可观的CPU负载。在60FPS的情况下，我们可以将每秒18000次的绘制调用降低到1125次。在Direct3D 10中，一次能够处理的采样输出（sampler input）还要高得多。 好的，我读到这里了，告诉我 WPF 是怎样处理像素着色器的！WPF 有一个可扩展的像素着色器API，一起的还有一些内置的效果。这允许程序员为他们的UI添加一些非常特别的效果。在Direct3D中，当你要为一个贴图添加着色器，典型的做法是使用intermediate rendertarget…毕竟，你不能对你正在写入数据的贴图进行采样。WPF 也是这样的，但不幸的是，它每次都会为每一帧生成一个新的贴图并且在完成后将贴图销毁。在每帧中，生成和销毁GPU资源是其中一件你能做的最慢的事情之一。如果这些中间的资源能够被重复利用，在使用着色器时将可能有一个可观的性能提升。如果你曾因为在使用这些硬件加速驱动的着色器而导致明显的CPU占用问题而感到困扰时，这就是原因。 或许这才是矢量图形在GPU渲染的方式!微软花费了大量的努力来解决这些问题，不幸的是这并不是针对WPF。答案是Direct2D。考虑这组在Direct2D中渲染的9个描边的圆形： 还记得WPF渲染一个描边的圆形需要多少次绘制调用吗？以及多少顶点缓存区被锁定？Direct2D只需要1次绘制调用。这是曲面细分看起来的样子： Direct2D尝试在一次中尽量绘制多地内容，最大化GPU使用并且最小化不必要的CPU负载。在这篇文章“Insights: Direct2D Rendering”底部，Mark Lawrence，使用大量细节解释了Direct2D的工作方式。你深入了解会发现，即使Direct2D运行的非常快，在很多方面它都可以在第二版本中进行改进。相信Direct2D的第二版会支持DX11的硬件曲面细分技术想必也不是那么不合逻辑。 查阅Direct2D的API，说其中很多代码就是从WPF里面拿的，也不是什么疯狂的想法。如果你看这个老视频,Micheal Wallent确实说过从这项技术上去创造一个原生的GDI技术作为替代。它有相似的几何图形API和命名。内部也坐着很多相同的事情，但是却更加优化和现代。 那Silverlight呢？我会深入讲Silverlight，但可能有点多余。Silverlight的渲染性能是低效的，但是因为另外的方式。它在CPU上进行栅格化（即使是着色器，如果我没记错的话，是使用汇编语言写的），但是CPU起码比GPU慢10-30倍。这导致你只有相当少的能力渲染UI，甚至更少的能力给到程序逻辑。它的硬件加速是非常基础的，并且几乎和WPF的Cache Composition一样，对于每个BitmapCached图像都要调用一次绘制调用。 我们能怎样做？这是一个我的客户在使用WPF或者Silverlight遇到性能问题时提到的共同问题。不幸的是，我也没有一个答复给到他们。有些可以为了他们特定的需求使用自己的框架。其他的，我尽量倾听，但是他们必须忍受它，毕竟并没有其他丰富的选择来替代WPF和Silverlight。","categories":[{"name":"翻译","slug":"翻译","permalink":"https://gandalfliang.github.io/categories/翻译/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://gandalfliang.github.io/tags/WPF/"},{"name":"DirectX","slug":"DirectX","permalink":"https://gandalfliang.github.io/tags/DirectX/"},{"name":"GPU","slug":"GPU","permalink":"https://gandalfliang.github.io/tags/GPU/"},{"name":"渲染","slug":"渲染","permalink":"https://gandalfliang.github.io/tags/渲染/"},{"name":"翻译","slug":"翻译","permalink":"https://gandalfliang.github.io/tags/翻译/"}]}]}